import codecs
import re
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from typing import Tuple, Optional
=======
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
from typing import Any, Tuple, Optional
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

_unicode_dots_re = re.compile('[\u002e\u3002\uff0e\uff61]')
<<<<<<< HEAD
=======
from typing import Any, Optional, Tuple

from .core import IDNAError, alabel, decode, encode, ulabel

_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7

class Codec(codecs.Codec):

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
    def encode(self, data: str, errors: str = 'strict') -> Tuple[bytes, int]:
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))
=======
=======
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
from typing import Any, Optional, Tuple

from .core import IDNAError, alabel, decode, encode, ulabel

_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")


class Codec(codecs.Codec):
    def encode(self, data: str, errors: str = "strict") -> Tuple[bytes, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
        if not data:
            return b"", 0

        return encode(data), len(data)

    def decode(self, data: bytes, errors: str = "strict") -> Tuple[str, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e

        if not data:
            return b"", 0

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
        return encode(data), len(data)

    def decode(self, data: bytes, errors: str = 'strict') -> Tuple[str, int]:
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
        if errors != 'strict':
            raise IDNAError("Unsupported error handling \"{0}\"".format(errors))
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
        return encode(data), len(data)

    def decode(self, data: bytes, errors: str = "strict") -> Tuple[str, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))

        if not data:
            return "", 0

<<<<<<< HEAD
<<<<<<< HEAD
        return encode(data), len(data)

<<<<<<< HEAD
class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[str, int]:  # type: ignore
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))
=======
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

        if not data:
            return '', 0

<<<<<<< HEAD
        labels = _unicode_dots_re.split(data)
        trailing_dot = ''
        if labels:
            if not labels[-1]:
                trailing_dot = '.'
=======
        return decode(data), len(data)

class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))

        if not data:
            return b'', 0

        labels = _unicode_dots_re.split(data)
        trailing_dot = b''
        if labels:
            if not labels[-1]:
                trailing_dot = b'.'
<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
=======
    def decode(self, data, errors='strict'):

        if errors != 'strict':
            raise IDNAError("Unsupported error handling \"{0}\"".format(errors))

        if not data:
            return u"", 0

=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
        return decode(data), len(data)


class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))

        if not data:
            return b"", 0

        labels = _unicode_dots_re.split(data)
        trailing_dot = b""
        if labels:
            if not labels[-1]:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
                trailing_dot = '.'
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
                trailing_dot = b"."
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
                trailing_dot = b"."
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
                trailing_dot = b"."
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
                del labels[-1]
            elif not final:
                # Keep potentially unfinished label until the next call
                del labels[-1]
                if labels:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                    trailing_dot = '.'
=======
                    trailing_dot = b'.'
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
                    trailing_dot = b'.'
=======
                    trailing_dot = '.'
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
                    trailing_dot = b"."
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
                    trailing_dot = b"."
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
                    trailing_dot = b"."
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e

        result = []
        size = 0
        for label in labels:
            result.append(alabel(label))
            if size:
                size += 1
            size += len(label)

        # Join with U+002E
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        result_str = '.'.join(result) + trailing_dot  # type: ignore
        size += len(trailing_dot)
        return result_str, size

class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
    def _buffer_decode(self, data: str, errors: str, final: bool) -> Tuple[str, int]:  # type: ignore
=======
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
        result_bytes = b'.'.join(result) + trailing_dot
        size += len(trailing_dot)
        return result_bytes, size

class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
        if errors != 'strict':
            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))

        if not data:
            return ('', 0)
<<<<<<< HEAD
=======

        if not isinstance(data, str):
            data = str(data, 'ascii')
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

        labels = _unicode_dots_re.split(data)
        trailing_dot = ''
        if labels:
            if not labels[-1]:
                trailing_dot = '.'
=======
        result = ".".join(result) + trailing_dot
=======
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
        result_bytes = b".".join(result) + trailing_dot
        size += len(trailing_dot)
        return result_bytes, size


class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))

        if not data:
            return ("", 0)

        if not isinstance(data, str):
            data = str(data, "ascii")

        labels = _unicode_dots_re.split(data)
        trailing_dot = ""
        if labels:
            if not labels[-1]:
                trailing_dot = "."
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
        result_bytes = b".".join(result) + trailing_dot
        size += len(trailing_dot)
        return result_bytes, size


class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))

        if not data:
            return ("", 0)

        if not isinstance(data, str):
            data = str(data, "ascii")

        labels = _unicode_dots_re.split(data)
        trailing_dot = ""
        if labels:
            if not labels[-1]:
                trailing_dot = "."
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
                del labels[-1]
            elif not final:
                # Keep potentially unfinished label until the next call
                del labels[-1]
                if labels:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
                    trailing_dot = '.'
=======
                    trailing_dot = u'.'
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
                    trailing_dot = "."
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
                    trailing_dot = "."
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
                    trailing_dot = "."
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e

        result = []
        size = 0
        for label in labels:
            result.append(ulabel(label))
            if size:
                size += 1
            size += len(label)

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
        result_str = '.'.join(result) + trailing_dot
=======
        result = u".".join(result) + trailing_dot
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
        result_str = ".".join(result) + trailing_dot
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
        result_str = ".".join(result) + trailing_dot
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
        result_str = ".".join(result) + trailing_dot
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
        size += len(trailing_dot)
        return (result_str, size)


class StreamWriter(Codec, codecs.StreamWriter):
    pass


class StreamReader(Codec, codecs.StreamReader):
    pass

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD

<<<<<<< HEAD
def getregentry() -> codecs.CodecInfo:
    # Compatibility as a search_function for codecs.register()
=======
def search_function(name: str) -> Optional[codecs.CodecInfo]:
    if name != 'idna2008':
        return None
<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    return codecs.CodecInfo(
        name='idna',
        encode=Codec().encode,  # type: ignore
        decode=Codec().decode,  # type: ignore
=======
=======
def getregentry():
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e

def search_function(name: str) -> Optional[codecs.CodecInfo]:
    if name != "idna2008":
        return None
    return codecs.CodecInfo(
<<<<<<< HEAD
=======

def search_function(name: str) -> Optional[codecs.CodecInfo]:
    if name != "idna2008":
        return None
    return codecs.CodecInfo(
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
        name=name,
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
    )
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======

codecs.register(search_function)
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======

codecs.register(search_function)
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======


codecs.register(search_function)
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======


codecs.register(search_function)
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======


codecs.register(search_function)
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
