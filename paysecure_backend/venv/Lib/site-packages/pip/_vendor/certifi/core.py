"""
certifi.py
~~~~~~~~~~

This module returns the installation location of cacert.pem or its contents.
"""
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
import sys


if sys.version_info >= (3, 11):

    from importlib.resources import as_file, files
=======
import os

try:
    from importlib.resources import path as get_path, read_text
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
import sys
import atexit

<<<<<<< HEAD
=======
import sys
import atexit

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
def exit_cacert_ctx() -> None:
    _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]


if sys.version_info >= (3, 11):

    from importlib.resources import as_file, files
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7

    _CACERT_CTX = None
    _CACERT_PATH = None

    def where() -> str:
        # This is slightly terrible, but we want to delay extracting the file
        # in cases where we're inside of a zipimport situation until someone
        # actually calls where(), but we don't want to re-extract the file
        # on every call of where(), so we'll do it once then store it in a
        # global variable.
        global _CACERT_CTX
        global _CACERT_PATH
        if _CACERT_PATH is None:
            # This is slightly janky, the importlib.resources API wants you to
            # manage the cleanup of this file, so it doesn't actually return a
            # path, it returns a context manager that will give you the path
            # when you enter it and will do any cleanup when you leave it. In
            # the common case of not needing a temporary file, it will just
            # return the file system location and the __exit__() is a no-op.
            #
            # We also have to hold onto the actual context manager, because
            # it will do the cleanup whenever it gets garbage collected, so
            # we will also store that at the global level as well.
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
            _CACERT_CTX = as_file(files("pip._vendor.certifi").joinpath("cacert.pem"))
            _CACERT_PATH = str(_CACERT_CTX.__enter__())

        return _CACERT_PATH

    def contents() -> str:
        return files("pip._vendor.certifi").joinpath("cacert.pem").read_text(encoding="ascii")
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7

elif sys.version_info >= (3, 7):

    from importlib.resources import path as get_path, read_text

    _CACERT_CTX = None
    _CACERT_PATH = None

    def where() -> str:
        # This is slightly terrible, but we want to delay extracting the
        # file in cases where we're inside of a zipimport situation until
        # someone actually calls where(), but we don't want to re-extract
        # the file on every call of where(), so we'll do it once then store
        # it in a global variable.
        global _CACERT_CTX
        global _CACERT_PATH
        if _CACERT_PATH is None:
            # This is slightly janky, the importlib.resources API wants you
            # to manage the cleanup of this file, so it doesn't actually
            # return a path, it returns a context manager that will give
            # you the path when you enter it and will do any cleanup when
            # you leave it. In the common case of not needing a temporary
            # file, it will just return the file system location and the
            # __exit__() is a no-op.
            #
            # We also have to hold onto the actual context manager, because
            # it will do the cleanup whenever it gets garbage collected, so
            # we will also store that at the global level as well.
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
            _CACERT_CTX = get_path("pip._vendor.certifi", "cacert.pem")
=======
            _CACERT_CTX = as_file(files("pip._vendor.certifi").joinpath("cacert.pem"))
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
            _CACERT_PATH = str(_CACERT_CTX.__enter__())
            atexit.register(exit_cacert_ctx)

        return _CACERT_PATH

<<<<<<< HEAD
<<<<<<< HEAD
    def contents() -> str:
        return read_text("pip._vendor.certifi", "cacert.pem", encoding="ascii")

else:
    import os
    import types
    from typing import Union

    Package = Union[types.ModuleType, str]
    Resource = Union[str, "os.PathLike"]

=======

except ImportError:
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
    # This fallback will work for Python versions prior to 3.7 that lack the
    # importlib.resources module but relies on the existing `where` function
    # so won't address issues with environments like PyOxidizer that don't set
    # __file__ on modules.
<<<<<<< HEAD
    def read_text(
        package: Package,
        resource: Resource,
        encoding: str = 'utf-8',
        errors: str = 'strict'
    ) -> str:
        with open(where(), encoding=encoding) as data:
=======
    def read_text(_module, _path, encoding="ascii"):
        with open(where(), "r", encoding=encoding) as data:
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
            return data.read()

    # If we don't have importlib.resources, then we will just do the old logic
    # of assuming we're on the filesystem and munge the path directly.
<<<<<<< HEAD
    def where() -> str:
=======
    def where():
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
        f = os.path.dirname(__file__)
=======
    def contents() -> str:
        return files("pip._vendor.certifi").joinpath("cacert.pem").read_text(encoding="ascii")

else:

    from importlib.resources import path as get_path, read_text
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d

    _CACERT_CTX = None
    _CACERT_PATH = None

<<<<<<< HEAD
<<<<<<< HEAD
    def contents() -> str:
        return read_text("pip._vendor.certifi", "cacert.pem", encoding="ascii")
=======

def contents():
    return read_text("certifi", "cacert.pem", encoding="ascii")
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def where() -> str:
        # This is slightly terrible, but we want to delay extracting the
        # file in cases where we're inside of a zipimport situation until
        # someone actually calls where(), but we don't want to re-extract
        # the file on every call of where(), so we'll do it once then store
        # it in a global variable.
        global _CACERT_CTX
        global _CACERT_PATH
        if _CACERT_PATH is None:
            # This is slightly janky, the importlib.resources API wants you
            # to manage the cleanup of this file, so it doesn't actually
            # return a path, it returns a context manager that will give
            # you the path when you enter it and will do any cleanup when
            # you leave it. In the common case of not needing a temporary
            # file, it will just return the file system location and the
            # __exit__() is a no-op.
            #
            # We also have to hold onto the actual context manager, because
            # it will do the cleanup whenever it gets garbage collected, so
            # we will also store that at the global level as well.
            _CACERT_CTX = get_path("pip._vendor.certifi", "cacert.pem")
            _CACERT_PATH = str(_CACERT_CTX.__enter__())
            atexit.register(exit_cacert_ctx)

<<<<<<< HEAD
=======

else:

    from importlib.resources import path as get_path, read_text

    _CACERT_CTX = None
    _CACERT_PATH = None

    def where() -> str:
        # This is slightly terrible, but we want to delay extracting the
        # file in cases where we're inside of a zipimport situation until
        # someone actually calls where(), but we don't want to re-extract
        # the file on every call of where(), so we'll do it once then store
        # it in a global variable.
        global _CACERT_CTX
        global _CACERT_PATH
        if _CACERT_PATH is None:
            # This is slightly janky, the importlib.resources API wants you
            # to manage the cleanup of this file, so it doesn't actually
            # return a path, it returns a context manager that will give
            # you the path when you enter it and will do any cleanup when
            # you leave it. In the common case of not needing a temporary
            # file, it will just return the file system location and the
            # __exit__() is a no-op.
            #
            # We also have to hold onto the actual context manager, because
            # it will do the cleanup whenever it gets garbage collected, so
            # we will also store that at the global level as well.
            _CACERT_CTX = get_path("pip._vendor.certifi", "cacert.pem")
            _CACERT_PATH = str(_CACERT_CTX.__enter__())
            atexit.register(exit_cacert_ctx)

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
        return _CACERT_PATH

    def contents() -> str:
        return read_text("pip._vendor.certifi", "cacert.pem", encoding="ascii")
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
