"""Validation of dependencies of packages"""

from __future__ import annotations

import logging
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from typing import Callable, Dict, List, NamedTuple, Optional, Set, Tuple
=======
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
from collections.abc import Generator, Iterable
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
from contextlib import suppress
from email.parser import Parser
from functools import reduce
from typing import (
    Callable,
<<<<<<< HEAD
    Dict,
    FrozenSet,
    Generator,
    Iterable,
    List,
    NamedTuple,
    Optional,
    Set,
    Tuple,
=======
from collections import namedtuple

from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.pkg_resources import RequirementParseError

from pip._internal.distributions import (
    make_distribution_for_install_requirement,
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
)
<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import LegacySpecifier
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import LegacyVersion

from pip._internal.distributions import make_distribution_for_install_requirement
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import DistributionVersion
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.deprecation import deprecated
=======
from pip._internal.utils.misc import get_installed_distributions
from pip._internal.utils.typing import MYPY_CHECK_RUNNING
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
    NamedTuple,
)

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.tags import Tag, parse_tag
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version

from pip._internal.distributions import make_distribution_for_install_requirement
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import BaseDistribution
from pip._internal.req.req_install import InstallRequirement
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d

logger = logging.getLogger(__name__)


<<<<<<< HEAD
<<<<<<< HEAD
class PackageDetails(NamedTuple):
<<<<<<< HEAD
    version: DistributionVersion
=======
    version: Version
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    dependencies: List[Requirement]


# Shorthands
PackageSet = Dict[NormalizedName, PackageDetails]
Missing = Tuple[NormalizedName, Requirement]
<<<<<<< HEAD
Conflicting = Tuple[NormalizedName, DistributionVersion, Requirement]
=======
Conflicting = Tuple[NormalizedName, Version, Requirement]
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

MissingDict = Dict[NormalizedName, List[Missing]]
ConflictingDict = Dict[NormalizedName, List[Conflicting]]
CheckResult = Tuple[MissingDict, ConflictingDict]
ConflictDetails = Tuple[PackageSet, CheckResult]


def create_package_set_from_installed() -> Tuple[PackageSet, bool]:
    """Converts a list of distributions into a PackageSet."""
=======
    # Shorthands
    PackageSet = Dict[str, 'PackageDetails']
    Missing = Tuple[str, Any]
    Conflicting = Tuple[str, str, Any]

    MissingDict = Dict[str, List[Missing]]
    ConflictingDict = Dict[str, List[Conflicting]]
    CheckResult = Tuple[MissingDict, ConflictingDict]
    ConflictDetails = Tuple[PackageSet, CheckResult]

PackageDetails = namedtuple('PackageDetails', ['version', 'requires'])
=======
class PackageDetails(NamedTuple):
    version: Version
    dependencies: list[Requirement]
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d


# Shorthands
PackageSet = dict[NormalizedName, PackageDetails]
Missing = tuple[NormalizedName, Requirement]
Conflicting = tuple[NormalizedName, Version, Requirement]

<<<<<<< HEAD
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
MissingDict = dict[NormalizedName, list[Missing]]
ConflictingDict = dict[NormalizedName, list[Conflicting]]
CheckResult = tuple[MissingDict, ConflictingDict]
ConflictDetails = tuple[PackageSet, CheckResult]


def create_package_set_from_installed() -> tuple[PackageSet, bool]:
    """Converts a list of distributions into a PackageSet."""
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
    package_set = {}
    problems = False
    env = get_default_environment()
    for dist in env.iter_installed_distributions(local_only=False, skip=()):
        name = dist.canonical_name
        try:
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
            dependencies = list(dist.iter_dependencies())
            package_set[name] = PackageDetails(dist.version, dependencies)
        except (OSError, ValueError) as e:
            # Don't crash on unreadable or broken metadata.
<<<<<<< HEAD
=======
            package_set[name] = PackageDetails(dist.version, dist.requires())
        except RequirementParseError as e:
            # Don't crash on broken metadata
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
            logger.warning("Error parsing requirements for %s: %s", name, e)
=======
            logger.warning("Error parsing dependencies of %s: %s", name, e)
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
            problems = True
    return package_set, problems


<<<<<<< HEAD
<<<<<<< HEAD
def check_package_set(
    package_set: PackageSet, should_ignore: Optional[Callable[[str], bool]] = None
) -> CheckResult:
=======
def check_package_set(package_set, should_ignore=None):
    # type: (PackageSet, Optional[Callable[[str], bool]]) -> CheckResult
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
def check_package_set(
    package_set: PackageSet, should_ignore: Callable[[str], bool] | None = None
) -> CheckResult:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
    """Check if a package set is consistent

    If should_ignore is passed, it should be a callable that takes a
    package name and returns a boolean.
    """

    warn_legacy_versions_and_specifiers(package_set)

    missing = {}
    conflicting = {}

    for package_name, package_detail in package_set.items():
        # Info about dependencies of package_name
<<<<<<< HEAD
<<<<<<< HEAD
        missing_deps: Set[Missing] = set()
        conflicting_deps: Set[Conflicting] = set()
=======
        missing_deps = set()  # type: Set[Missing]
        conflicting_deps = set()  # type: Set[Conflicting]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
        missing_deps: set[Missing] = set()
        conflicting_deps: set[Conflicting] = set()
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d

        if should_ignore and should_ignore(package_name):
            continue

        for req in package_detail.dependencies:
            name = canonicalize_name(req.name)

            # Check if it's missing
            if name not in package_set:
                missed = True
                if req.marker is not None:
                    missed = req.marker.evaluate({"extra": ""})
                if missed:
                    missing_deps.add((name, req))
                continue

            # Check if there's a conflict
            version = package_set[name].version
            if not req.specifier.contains(version, prereleases=True):
                conflicting_deps.add((name, version, req))

        if missing_deps:
            missing[package_name] = sorted(missing_deps, key=str)
        if conflicting_deps:
            conflicting[package_name] = sorted(conflicting_deps, key=str)

    return missing, conflicting


<<<<<<< HEAD
<<<<<<< HEAD
def check_install_conflicts(to_install: List[InstallRequirement]) -> ConflictDetails:
=======
def check_install_conflicts(to_install):
    # type: (List[InstallRequirement]) -> ConflictDetails
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
def check_install_conflicts(to_install: list[InstallRequirement]) -> ConflictDetails:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
    """For checking if the dependency graph would be consistent after \
    installing given requirements
    """
    # Start from the current state
    package_set, _ = create_package_set_from_installed()
    # Install packages
    would_be_installed = _simulate_installation_of(to_install, package_set)

    # Only warn about directly-dependent packages; create a whitelist of them
    whitelist = _create_whitelist(would_be_installed, package_set)

    return (
        package_set,
        check_package_set(
            package_set, should_ignore=lambda name: name not in whitelist
        ),
    )


<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
def check_unsupported(
    packages: Iterable[BaseDistribution],
    supported_tags: Iterable[Tag],
) -> Generator[BaseDistribution, None, None]:
    for p in packages:
        with suppress(FileNotFoundError):
            wheel_file = p.read_text("WHEEL")
<<<<<<< HEAD
            wheel_tags: FrozenSet[Tag] = reduce(
=======
            wheel_tags: frozenset[Tag] = reduce(
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
                frozenset.union,
                map(parse_tag, Parser().parsestr(wheel_file).get_all("Tag", [])),
                frozenset(),
            )
            if wheel_tags.isdisjoint(supported_tags):
                yield p
<<<<<<< HEAD


>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
def _simulate_installation_of(
    to_install: List[InstallRequirement], package_set: PackageSet
) -> Set[NormalizedName]:
    """Computes the version of packages after installing to_install."""
=======
def _simulate_installation_of(to_install, package_set):
    # type: (List[InstallRequirement], PackageSet) -> Set[str]
    """Computes the version of packages after installing to_install.
    """

>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======


def _simulate_installation_of(
    to_install: list[InstallRequirement], package_set: PackageSet
) -> set[NormalizedName]:
    """Computes the version of packages after installing to_install."""
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
    # Keep track of packages that were installed
    installed = set()

    # Modify it as installing requirement_set would (assuming no errors)
    for inst_req in to_install:
        abstract_dist = make_distribution_for_install_requirement(inst_req)
        dist = abstract_dist.get_metadata_distribution()
        name = dist.canonical_name
        package_set[name] = PackageDetails(dist.version, list(dist.iter_dependencies()))

        installed.add(name)

    return installed


<<<<<<< HEAD
<<<<<<< HEAD
def _create_whitelist(
    would_be_installed: Set[NormalizedName], package_set: PackageSet
) -> Set[NormalizedName]:
=======
def _create_whitelist(would_be_installed, package_set):
    # type: (Set[str], PackageSet) -> Set[str]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
def _create_whitelist(
    would_be_installed: set[NormalizedName], package_set: PackageSet
) -> set[NormalizedName]:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
    packages_affected = set(would_be_installed)

    for package_name in package_set:
        if package_name in packages_affected:
            continue

        for req in package_set[package_name].dependencies:
            if canonicalize_name(req.name) in packages_affected:
                packages_affected.add(package_name)
                break

    return packages_affected


def warn_legacy_versions_and_specifiers(package_set: PackageSet) -> None:
    for project_name, package_details in package_set.items():
        if isinstance(package_details.version, LegacyVersion):
            deprecated(
                reason=(
                    f"{project_name} {package_details.version} "
                    f"has a non-standard version number."
                ),
                replacement=(
                    f"to upgrade to a newer version of {project_name} "
                    f"or contact the author to suggest that they "
                    f"release a version with a conforming version number"
                ),
                issue=12063,
                gone_in="24.1",
            )
        for dep in package_details.dependencies:
            if any(isinstance(spec, LegacySpecifier) for spec in dep.specifier):
                deprecated(
                    reason=(
                        f"{project_name} {package_details.version} "
                        f"has a non-standard dependency specifier {dep}."
                    ),
                    replacement=(
                        f"to upgrade to a newer version of {project_name} "
                        f"or contact the author to suggest that they "
                        f"release a version with a conforming dependency specifiers"
                    ),
                    issue=12063,
                    gone_in="24.1",
                )
