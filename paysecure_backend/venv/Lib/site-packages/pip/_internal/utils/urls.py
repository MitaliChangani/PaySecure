import os
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
import string
import urllib.parse
import urllib.request
from typing import Optional
=======
import sys
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
import string
import urllib.parse
import urllib.request
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
import string
import urllib.parse
import urllib.request
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
import string
import urllib.parse
import urllib.request
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e

from .compat import WINDOWS


<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
def get_url_scheme(url: str) -> Optional[str]:
    if ":" not in url:
        return None
    return url.split(":", 1)[0].lower()


def path_to_url(path: str) -> str:
=======
def get_url_scheme(url):
    # type: (Union[str, Text]) -> Optional[Text]
    if ':' not in url:
        return None
    return url.split(':', 1)[0].lower()


def path_to_url(path):
    # type: (Union[str, Text]) -> str
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
def path_to_url(path: str) -> str:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
def path_to_url(path: str) -> str:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
def path_to_url(path: str) -> str:
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
    """
    Convert a path to a file: URL.  The path will be made absolute and have
    quoted path parts.
    """
    path = os.path.normpath(os.path.abspath(path))
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
    url = urllib.parse.urljoin("file:", urllib.request.pathname2url(path))
=======
    url = urllib_parse.urljoin('file:', urllib_request.pathname2url(path))
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    url = urllib.parse.urljoin("file://", urllib.request.pathname2url(path))
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
    url = urllib.parse.urljoin("file://", urllib.request.pathname2url(path))
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
=======
    url = urllib.parse.urljoin("file://", urllib.request.pathname2url(path))
>>>>>>> f4a864551d6581bb51150af1ef058b46b534e30e
    return url


def url_to_path(url: str) -> str:
    """
    Convert a file: URL to a path.
    """
    assert url.startswith(
        "file:"
    ), f"You can only turn file: urls into filenames (not {url!r})"

    _, netloc, path, _, _ = urllib.parse.urlsplit(url)

    if not netloc or netloc == "localhost":
        # According to RFC 8089, same as empty authority.
        netloc = ""
    elif WINDOWS:
        # If we have a UNC path, prepend UNC share notation.
        netloc = "\\\\" + netloc
    else:
        raise ValueError(
            f"non-local file URIs are not supported on this platform: {url!r}"
        )

    path = urllib.request.url2pathname(netloc + path)

    # On Windows, urlsplit parses the path as something like "/C:/Users/foo".
    # This creates issues for path-related functions like io.open(), so we try
    # to detect and strip the leading slash.
    if (
        WINDOWS
        and not netloc  # Not UNC.
        and len(path) >= 3
        and path[0] == "/"  # Leading slash to strip.
        and path[1] in string.ascii_letters  # Drive letter.
        and path[2:4] in (":", ":/")  # Colon + end of string, or colon + absolute path.
    ):
        path = path[1:]

    return path
