"""Stuff that differs in different Python versions and platform
distributions."""

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
=======
# The following comment should be removed at some point in the future.
# mypy: disallow-untyped-defs=False

from __future__ import absolute_import, division

import codecs
import locale
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
import importlib.resources
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
import importlib.resources
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
import logging
import os
import sys
from typing import IO

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
__all__ = ["get_path_uid", "stdlib_pkgs", "WINDOWS"]
=======
from pip._vendor.six import PY2, text_type

from pip._internal.utils.typing import MYPY_CHECK_RUNNING

if MYPY_CHECK_RUNNING:
    from typing import Optional, Text, Tuple, Union

try:
    import ipaddress
except ImportError:
    try:
        from pip._vendor import ipaddress  # type: ignore
    except ImportError:
        import ipaddr as ipaddress  # type: ignore
        ipaddress.ip_address = ipaddress.IPAddress  # type: ignore
        ipaddress.ip_network = ipaddress.IPNetwork  # type: ignore


__all__ = [
    "ipaddress", "uses_pycache", "console_to_str",
    "get_path_uid", "stdlib_pkgs", "WINDOWS", "samefile", "get_terminal_size",
]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
__all__ = ["get_path_uid", "stdlib_pkgs", "tomllib", "WINDOWS"]
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
__all__ = ["get_path_uid", "stdlib_pkgs", "tomllib", "WINDOWS"]
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7


logger = logging.getLogger(__name__)


def has_tls() -> bool:
    try:
        import _ssl  # noqa: F401  # ignore unused

        return True
    except ImportError:
        pass

    from pip._vendor.urllib3.util import IS_PYOPENSSL

    return IS_PYOPENSSL


def get_path_uid(path: str) -> int:
    """
    Return path's uid.

    Does not follow symlinks:
        https://github.com/pypa/pip/pull/935#discussion_r5307003

    Placed this function in compat due to differences on AIX and
    Jython, that should eventually go away.

    :raises OSError: When path is a symlink or can't be read.
    """
    if hasattr(os, "O_NOFOLLOW"):
        fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)
        file_uid = os.fstat(fd).st_uid
        os.close(fd)
    else:  # AIX and Jython
        # WARNING: time of check vulnerability, but best we can do w/o NOFOLLOW
        if not os.path.islink(path):
            # older versions of Jython don't have `os.fstat`
            file_uid = os.stat(path).st_uid
        else:
            # raise OSError for parity with os.O_NOFOLLOW above
            raise OSError(f"{path} is a symlink; Will not return uid for symlinks")
    return file_uid


<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
# The importlib.resources.open_text function was deprecated in 3.11 with suggested
# replacement we use below.
if sys.version_info < (3, 11):
    open_text_resource = importlib.resources.open_text
else:
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
=======
def expanduser(path):
    # type: (str) -> str
    """
    Expand ~ and ~user constructions.
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e

<<<<<<< HEAD
=======

>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
<<<<<<< HEAD
=======

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
    def open_text_resource(
        package: str, resource: str, encoding: str = "utf-8", errors: str = "strict"
    ) -> IO[str]:
        return (importlib.resources.files(package) / resource).open(
            "r", encoding=encoding, errors=errors
        )
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7
<<<<<<< HEAD
=======
    Includes a workaround for https://bugs.python.org/issue14768
    """
    expanded = os.path.expanduser(path)
    if path.startswith('~/') and expanded.startswith('//'):
        expanded = expanded[1:]
    return expanded
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
<<<<<<< HEAD
=======


if sys.version_info >= (3, 11):
    import tomllib
else:
    from pip._vendor import tomli as tomllib
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
=======
>>>>>>> 7d8d14f0a20009c9cb2e4f1d97ae48f47503bac7


if sys.version_info >= (3, 11):
    import tomllib
else:
    from pip._vendor import tomli as tomllib
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d


>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
# packages in the stdlib that may have installation metadata, but should not be
# considered 'installed'.  this theoretically could be determined based on
# dist.location (py27:`sysconfig.get_paths()['stdlib']`,
# py26:sysconfig.get_config_vars('LIBDEST')), but fear platform variation may
# make this ineffective, so hard-coding
stdlib_pkgs = {"python", "wsgiref", "argparse"}


# windows detection, covers cpython and ironpython
WINDOWS = sys.platform.startswith("win") or (sys.platform == "cli" and os.name == "nt")
