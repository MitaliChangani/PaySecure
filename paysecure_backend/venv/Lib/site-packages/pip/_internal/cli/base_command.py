"""Base Command class, and related routines"""

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
import functools
=======
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
=======
from __future__ import absolute_import, print_function
=======
from __future__ import annotations
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
from __future__ import annotations
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
import logging
import logging.config
import optparse
import os
import sys
import traceback
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from optparse import Values
<<<<<<< HEAD
from typing import Any, Callable, List, Optional, Tuple
=======
from typing import List, Optional, Tuple
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

from pip._vendor.rich import traceback as rich_traceback
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
from optparse import Values
from typing import Callable

from pip._vendor.rich import reconfigure
from pip._vendor.rich import traceback as rich_traceback
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

from pip._internal.cli import cmdoptions
from pip._internal.cli.command_context import CommandContextMixIn
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.cli.status_codes import (
    ERROR,
    PREVIOUS_BUILD_DIR_ERROR,
    UNKNOWN_ERROR,
    VIRTUALENV_NOT_FOUND,
)
from pip._internal.exceptions import (
    BadCommand,
    CommandError,
    DiagnosticPipError,
    InstallationError,
    NetworkConnectionError,
    PreviousBuildDirError,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
    SubProcessError,
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
    UninstallationError,
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
)
from pip._internal.utils.filesystem import check_path_owner
from pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging
from pip._internal.utils.misc import get_prog, normalize_path
from pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry
from pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry
from pip._internal.utils.virtualenv import running_under_virtualenv

__all__ = ["Command"]

logger = logging.getLogger(__name__)


class Command(CommandContextMixIn):
    usage: str = ""
    ignore_require_venv: bool = False

    def __init__(self, name: str, summary: str, isolated: bool = False) -> None:
        super().__init__()

        self.name = name
        self.summary = summary
        self.parser = ConfigOptionParser(
            usage=self.usage,
            prog=f"{get_prog()} {name}",
            formatter=UpdatingDefaultsHelpFormatter(),
            add_help_option=False,
            name=name,
            description=self.__doc__,
            isolated=isolated,
        )

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        self.tempdir_registry: Optional[TempDirRegistry] = None
=======
        self.tempdir_registry = None  # type: Optional[TempDirRegistry]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
        self.tempdir_registry: TempDirRegistry | None = None
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
        self.tempdir_registry: TempDirRegistry | None = None
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

        # Commands should add options to this option group
        optgroup_name = f"{self.name.capitalize()} Options"
        self.cmd_opts = optparse.OptionGroup(self.parser, optgroup_name)

        # Add the general options
        gen_opts = cmdoptions.make_option_group(
            cmdoptions.general_group,
            self.parser,
        )
        self.parser.add_option_group(gen_opts)

        self.add_options()

    def add_options(self) -> None:
        pass

    def handle_pip_version_check(self, options: Values) -> None:
        """
        This is a no-op so that commands by default do not do the pip version
        check.
        """
        # Make sure we do the pip version check if the index_group options
        # are present.
        assert not hasattr(options, "no_index")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def run(self, options: Values, args: List[str]) -> int:
        raise NotImplementedError

<<<<<<< HEAD
=======
    def _run_wrapper(self, level_number: int, options: Values, args: List[str]) -> int:
=======
    def run(self, options: Values, args: list[str]) -> int:
        raise NotImplementedError

    def _run_wrapper(self, level_number: int, options: Values, args: list[str]) -> int:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        def _inner_run() -> int:
            try:
                return self.run(options, args)
            finally:
                self.handle_pip_version_check(options)

        if options.debug_mode:
            rich_traceback.install(show_locals=True)
            return _inner_run()

        try:
            status = _inner_run()
            assert isinstance(status, int)
            return status
        except DiagnosticPipError as exc:
            logger.error("%s", exc, extra={"rich": True})
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except PreviousBuildDirError as exc:
            logger.critical(str(exc))
            logger.debug("Exception information:", exc_info=True)

            return PREVIOUS_BUILD_DIR_ERROR
        except (
            InstallationError,
            BadCommand,
            NetworkConnectionError,
        ) as exc:
            logger.critical(str(exc))
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except CommandError as exc:
            logger.critical("%s", exc)
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except BrokenStdoutLoggingError:
            # Bypass our logger and write any remaining messages to
            # stderr because stdout no longer works.
            print("ERROR: Pipe to stdout was broken", file=sys.stderr)
            if level_number <= logging.DEBUG:
                traceback.print_exc(file=sys.stderr)

            return ERROR
        except KeyboardInterrupt:
            logger.critical("Operation cancelled by user")
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except BaseException:
            logger.critical("Exception:", exc_info=True)

            return UNKNOWN_ERROR

<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    def parse_args(self, args: List[str]) -> Tuple[Values, List[str]]:
        # factored out for testability
        return self.parser.parse_args(args)

    def main(self, args: List[str]) -> int:
=======
    def run(self, options, args):
        # type: (Values, List[Any]) -> int
=======
    def run(self, options: Values, args: list[str]) -> int:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
        raise NotImplementedError

    def _run_wrapper(self, level_number: int, options: Values, args: list[str]) -> int:
        def _inner_run() -> int:
            try:
                return self.run(options, args)
            finally:
                self.handle_pip_version_check(options)

        if options.debug_mode:
            rich_traceback.install(show_locals=True)
            return _inner_run()

        try:
            status = _inner_run()
            assert isinstance(status, int)
            return status
        except DiagnosticPipError as exc:
            logger.error("%s", exc, extra={"rich": True})
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except PreviousBuildDirError as exc:
            logger.critical(str(exc))
            logger.debug("Exception information:", exc_info=True)

            return PREVIOUS_BUILD_DIR_ERROR
        except (
            InstallationError,
            BadCommand,
            NetworkConnectionError,
        ) as exc:
            logger.critical(str(exc))
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except CommandError as exc:
            logger.critical("%s", exc)
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except BrokenStdoutLoggingError:
            # Bypass our logger and write any remaining messages to
            # stderr because stdout no longer works.
            print("ERROR: Pipe to stdout was broken", file=sys.stderr)
            if level_number <= logging.DEBUG:
                traceback.print_exc(file=sys.stderr)

            return ERROR
        except KeyboardInterrupt:
            logger.critical("Operation cancelled by user")
            logger.debug("Exception information:", exc_info=True)

            return ERROR
        except BaseException:
            logger.critical("Exception:", exc_info=True)

            return UNKNOWN_ERROR

    def parse_args(self, args: list[str]) -> tuple[Values, list[str]]:
        # factored out for testability
        return self.parser.parse_args(args)

<<<<<<< HEAD
    def main(self, args):
        # type: (List[str]) -> int
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def main(self, args: list[str]) -> int:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def parse_args(self, args: list[str]) -> tuple[Values, list[str]]:
        # factored out for testability
        return self.parser.parse_args(args)

    def main(self, args: list[str]) -> int:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        try:
            with self.main_context():
                return self._main(args)
        finally:
            logging.shutdown()

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def _main(self, args: List[str]) -> int:
=======
    def _main(self, args):
        # type: (List[str]) -> int
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def _main(self, args: list[str]) -> int:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def _main(self, args: list[str]) -> int:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        # We must initialize this before the tempdir manager, otherwise the
        # configuration would not be accessible by the time we clean up the
        # tempdir manager.
        self.tempdir_registry = self.enter_context(tempdir_registry())
        # Intentionally set as early as possible so globally-managed temporary
        # directories are available to the rest of the code.
        self.enter_context(global_tempdir_manager())

        options, args = self.parse_args(args)

        # Set verbosity so that it can be used elsewhere.
        self.verbosity = options.verbose - options.quiet
        if options.debug_mode:
            self.verbosity = 2

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
        reconfigure(no_color=options.no_color)
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
        reconfigure(no_color=options.no_color)
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        if hasattr(options, "progress_bar") and options.progress_bar == "auto":
            options.progress_bar = "on" if self.verbosity >= 0 else "off"

        reconfigure(no_color=options.no_color)
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        level_number = setup_logging(
            verbosity=self.verbosity,
            no_color=options.no_color,
            user_log_file=options.log,
        )

        always_enabled_features = set(options.features_enabled) & set(
            cmdoptions.ALWAYS_ENABLED_FEATURES
        )
        if always_enabled_features:
            logger.warning(
                "The following features are always enabled: %s. ",
                ", ".join(sorted(always_enabled_features)),
            )

        # Make sure that the --python argument isn't specified after the
        # subcommand. We can tell, because if --python was specified,
        # we should only reach this point if we're running in the created
        # subprocess, which has the _PIP_RUNNING_IN_SUBPROCESS environment
        # variable set.
        if options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
            logger.critical(
                "The --python option must be placed before the pip subcommand name"
            )
            sys.exit(ERROR)

        # TODO: Try to get these passing down from the command?
        #       without resorting to os.environ to hold these.
        #       This also affects isolated builds and it should.

        if options.no_input:
            os.environ["PIP_NO_INPUT"] = "1"

        if options.exists_action:
            os.environ["PIP_EXISTS_ACTION"] = " ".join(options.exists_action)

        if options.require_venv and not self.ignore_require_venv:
            # If a venv is required check if it can really be found
            if not running_under_virtualenv():
                logger.critical("Could not find an activated virtualenv (required).")
                sys.exit(VIRTUALENV_NOT_FOUND)

        if options.cache_dir:
            options.cache_dir = normalize_path(options.cache_dir)
            if not check_path_owner(options.cache_dir):
                logger.warning(
                    "The directory '%s' or its parent directory is not owned "
                    "or is not writable by the current user. The cache "
                    "has been disabled. Check the permissions and owner of "
                    "that directory. If executing pip with sudo, you should "
                    "use sudo's -H flag.",
                    options.cache_dir,
                )
                options.cache_dir = None

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        def intercepts_unhandled_exc(
            run_func: Callable[..., int]
        ) -> Callable[..., int]:
            @functools.wraps(run_func)
            def exc_logging_wrapper(*args: Any) -> int:
                try:
                    status = run_func(*args)
                    assert isinstance(status, int)
                    return status
                except DiagnosticPipError as exc:
                    logger.error("%s", exc, extra={"rich": True})
                    logger.debug("Exception information:", exc_info=True)

                    return ERROR
                except PreviousBuildDirError as exc:
                    logger.critical(str(exc))
                    logger.debug("Exception information:", exc_info=True)

                    return PREVIOUS_BUILD_DIR_ERROR
                except (
                    InstallationError,
                    UninstallationError,
                    BadCommand,
                    NetworkConnectionError,
                ) as exc:
                    logger.critical(str(exc))
                    logger.debug("Exception information:", exc_info=True)

                    return ERROR
                except CommandError as exc:
                    logger.critical("%s", exc)
                    logger.debug("Exception information:", exc_info=True)

                    return ERROR
                except BrokenStdoutLoggingError:
                    # Bypass our logger and write any remaining messages to
                    # stderr because stdout no longer works.
                    print("ERROR: Pipe to stdout was broken", file=sys.stderr)
                    if level_number <= logging.DEBUG:
                        traceback.print_exc(file=sys.stderr)

                    return ERROR
                except KeyboardInterrupt:
                    logger.critical("Operation cancelled by user")
                    logger.debug("Exception information:", exc_info=True)

                    return ERROR
                except BaseException:
                    logger.critical("Exception:", exc_info=True)

                    return UNKNOWN_ERROR

            return exc_logging_wrapper

        try:
            if not options.debug_mode:
                run = intercepts_unhandled_exc(self.run)
            else:
                run = self.run
                rich_traceback.install(show_locals=True)
            return run(options, args)
        finally:
            self.handle_pip_version_check(options)
=======
        return self._run_wrapper(level_number, options, args)
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
        return self._run_wrapper(level_number, options, args)
=======
        if getattr(options, "build_dir", None):
            deprecated(
                reason=(
                    "The -b/--build/--build-dir/--build-directory "
                    "option is deprecated."
                ),
                replacement=(
                    "use the TMPDIR/TEMP/TMP environment variable, "
                    "possibly combined with --no-clean"
                ),
                gone_in="20.3",
                issue=8333,
            )

        if 'resolver' in options.unstable_features:
            logger.critical(
                "--unstable-feature=resolver is no longer supported, and "
                "has been replaced with --use-feature=2020-resolver instead."
            )
            sys.exit(ERROR)

        try:
            status = self.run(options, args)
            assert isinstance(status, int)
            return status
        except PreviousBuildDirError as exc:
            logger.critical(str(exc))
            logger.debug('Exception information:', exc_info=True)

            return PREVIOUS_BUILD_DIR_ERROR
        except (InstallationError, UninstallationError, BadCommand,
                SubProcessError, NetworkConnectionError) as exc:
            logger.critical(str(exc))
            logger.debug('Exception information:', exc_info=True)

            return ERROR
        except CommandError as exc:
            logger.critical('%s', exc)
            logger.debug('Exception information:', exc_info=True)

            return ERROR
        except BrokenStdoutLoggingError:
            # Bypass our logger and write any remaining messages to stderr
            # because stdout no longer works.
            print('ERROR: Pipe to stdout was broken', file=sys.stderr)
            if level_number <= logging.DEBUG:
                traceback.print_exc(file=sys.stderr)

            return ERROR
        except KeyboardInterrupt:
            logger.critical('Operation cancelled by user')
            logger.debug('Exception information:', exc_info=True)

            return ERROR
        except BaseException:
            logger.critical('Exception:', exc_info=True)

            return UNKNOWN_ERROR
        finally:
            self.handle_pip_version_check(options)
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
        return self._run_wrapper(level_number, options, args)

=======
        return self._run_wrapper(level_number, options, args)

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def handler_map(self) -> dict[str, Callable[[Values, list[str]], None]]:
        """
        map of names to handler actions for commands with sub-actions
        """
        return {}
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
