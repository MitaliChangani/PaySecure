<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from typing import FrozenSet, Iterable, Optional, Tuple, Union
=======
from dataclasses import dataclass
from typing import FrozenSet, Iterable, Optional, Tuple
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName
from pip._vendor.packaging.version import LegacyVersion, Version
=======
from dataclasses import dataclass
from typing import FrozenSet, Iterable, Optional, Tuple
=======
from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.utils.typing import MYPY_CHECK_RUNNING
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
from __future__ import annotations

from collections.abc import Iterable
from dataclasses import dataclass
from typing import Optional
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d

from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName
from pip._vendor.packaging.version import Version

from pip._internal.models.link import Link, links_equivalent
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.hashes import Hashes

<<<<<<< HEAD
<<<<<<< HEAD
CandidateLookup = Tuple[Optional["Candidate"], Optional[InstallRequirement]]
<<<<<<< HEAD
CandidateVersion = Union[LegacyVersion, Version]
=======
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df


def format_name(project: NormalizedName, extras: FrozenSet[NormalizedName]) -> str:
=======
    from pip._internal.models.link import Link
    from pip._internal.req.req_install import InstallRequirement

    CandidateLookup = Tuple[
        Optional["Candidate"],
        Optional[InstallRequirement],
    ]


def format_name(project, extras):
    # type: (str, FrozenSet[str]) -> str
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
CandidateLookup = tuple[Optional["Candidate"], Optional[InstallRequirement]]


def format_name(project: NormalizedName, extras: frozenset[NormalizedName]) -> str:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
from __future__ import annotations

from collections.abc import Iterable
from dataclasses import dataclass
from typing import Optional

from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName
from pip._vendor.packaging.version import Version

from pip._internal.models.link import Link, links_equivalent
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.hashes import Hashes

CandidateLookup = tuple[Optional["Candidate"], Optional[InstallRequirement]]


def format_name(project: NormalizedName, extras: frozenset[NormalizedName]) -> str:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    if not extras:
        return project
    extras_expr = ",".join(sorted(extras))
    return f"{project}[{extras_expr}]"


<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
<<<<<<< HEAD
@dataclass(frozen=True)
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
class Constraint:
<<<<<<< HEAD
    def __init__(
        self, specifier: SpecifierSet, hashes: Hashes, links: FrozenSet[Link]
    ) -> None:
        self.specifier = specifier
        self.hashes = hashes
        self.links = links
=======
    specifier: SpecifierSet
    hashes: Hashes
    links: FrozenSet[Link]
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

    @classmethod
    def empty(cls) -> "Constraint":
        return Constraint(SpecifierSet(), Hashes(), frozenset())

    @classmethod
    def from_ireq(cls, ireq: InstallRequirement) -> "Constraint":
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
@dataclass(frozen=True)
class Constraint:
    specifier: SpecifierSet
    hashes: Hashes
    links: frozenset[Link]

    @classmethod
    def empty(cls) -> Constraint:
        return Constraint(SpecifierSet(), Hashes(), frozenset())

    @classmethod
    def from_ireq(cls, ireq: InstallRequirement) -> Constraint:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        links = frozenset([ireq.link]) if ireq.link else frozenset()
        return Constraint(ireq.specifier, ireq.hashes(trust_internet=False), links)

    def __bool__(self) -> bool:
        return bool(self.specifier) or bool(self.hashes) or bool(self.links)

<<<<<<< HEAD
<<<<<<< HEAD
    def __and__(self, other: InstallRequirement) -> "Constraint":
=======
    def __and__(self, other: InstallRequirement) -> Constraint:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def __and__(self, other: InstallRequirement) -> Constraint:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        if not isinstance(other, InstallRequirement):
            return NotImplemented
        specifier = self.specifier & other.specifier
        hashes = self.hashes & other.hashes(trust_internet=False)
        links = self.links
        if other.link:
            links = links.union([other.link])
        return Constraint(specifier, hashes, links)

<<<<<<< HEAD
<<<<<<< HEAD
    def is_satisfied_by(self, candidate: "Candidate") -> bool:
=======
    def is_satisfied_by(self, candidate: Candidate) -> bool:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def is_satisfied_by(self, candidate: Candidate) -> bool:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        # Reject if there are any mismatched URL constraints on this package.
        if self.links and not all(_match_link(link, candidate) for link in self.links):
            return False
        # We can safely always allow prereleases here since PackageFinder
        # already implements the prerelease logic, and would have filtered out
        # prerelease candidates if the user does not expect them.
        return self.specifier.contains(candidate.version, prereleases=True)


class Requirement:
<<<<<<< HEAD
<<<<<<< HEAD
=======
class Requirement(object):
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    @property
    def project_name(self) -> NormalizedName:
        """The "project name" of a requirement.

        This is different from ``name`` if this requirement contains extras,
        in which case ``name`` would contain the ``[...]`` part, while this
        refers to the name of the project.
        """
        raise NotImplementedError("Subclass should override")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    @property
    def name(self) -> str:
        """The name identifying this requirement in the resolver.

        This is different from ``project_name`` if this requirement contains
        extras, where ``project_name`` would not contain the ``[...]`` part.
        """
        raise NotImplementedError("Subclass should override")

<<<<<<< HEAD
<<<<<<< HEAD
    def is_satisfied_by(self, candidate: "Candidate") -> bool:
=======
    def is_satisfied_by(self, candidate):
        # type: (Candidate) -> bool
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def is_satisfied_by(self, candidate: Candidate) -> bool:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def is_satisfied_by(self, candidate: Candidate) -> bool:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return False

    def get_candidate_lookup(self) -> CandidateLookup:
        raise NotImplementedError("Subclass should override")

    def format_for_error(self) -> str:
        raise NotImplementedError("Subclass should override")


<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
def _match_link(link: Link, candidate: "Candidate") -> bool:
=======
def _match_link(link: Link, candidate: Candidate) -> bool:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
def _match_link(link: Link, candidate: Candidate) -> bool:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    if candidate.source_link:
        return links_equivalent(link, candidate.source_link)
    return False


class Candidate:
<<<<<<< HEAD
<<<<<<< HEAD
=======
class Candidate(object):
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    @property
    def project_name(self) -> NormalizedName:
        """The "project name" of the candidate.

        This is different from ``name`` if this candidate contains extras,
        in which case ``name`` would contain the ``[...]`` part, while this
        refers to the name of the project.
        """
        raise NotImplementedError("Override in subclass")

    @property
    def name(self) -> str:
        """The name identifying this candidate in the resolver.

        This is different from ``project_name`` if this candidate contains
        extras, where ``project_name`` would not contain the ``[...]`` part.
        """
        raise NotImplementedError("Override in subclass")

    @property
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def version(self) -> CandidateVersion:
=======
    def is_installed(self):
        # type: () -> bool
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
    def version(self) -> Version:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def version(self) -> Version:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        raise NotImplementedError("Override in subclass")

    @property
    def is_installed(self) -> bool:
        raise NotImplementedError("Override in subclass")

    @property
    def is_editable(self) -> bool:
        raise NotImplementedError("Override in subclass")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    @property
    def source_link(self) -> Optional[Link]:
        raise NotImplementedError("Override in subclass")

    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        raise NotImplementedError("Override in subclass")

    def get_install_requirement(self) -> Optional[InstallRequirement]:
        raise NotImplementedError("Override in subclass")

    def format_for_error(self) -> str:
=======
    def iter_dependencies(self, with_requires):
        # type: (bool) -> Iterable[Optional[Requirement]]
=======
    @property
    def source_link(self) -> Link | None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    @property
    def source_link(self) -> Link | None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        raise NotImplementedError("Override in subclass")

    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
        raise NotImplementedError("Override in subclass")

<<<<<<< HEAD
<<<<<<< HEAD
    def format_for_error(self):
        # type: () -> str
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def get_install_requirement(self) -> InstallRequirement | None:
        raise NotImplementedError("Override in subclass")

    def format_for_error(self) -> str:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        raise NotImplementedError("Subclass should override")
