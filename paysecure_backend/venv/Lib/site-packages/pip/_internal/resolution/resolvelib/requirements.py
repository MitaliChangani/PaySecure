<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
from typing import Any, Optional
=======
from pip._vendor.packaging.utils import canonicalize_name

<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
=======
from pip._internal.utils.typing import MYPY_CHECK_RUNNING
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e

from .base import Requirement, format_name

if MYPY_CHECK_RUNNING:
    from pip._vendor.packaging.specifiers import SpecifierSet

    from pip._internal.req.req_install import InstallRequirement

    from .base import Candidate, CandidateLookup


class ExplicitRequirement(Requirement):
    def __init__(self, candidate):
        # type: (Candidate) -> None
        self.candidate = candidate

<<<<<<< HEAD
    def __str__(self) -> str:
        return str(self.candidate)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.candidate!r})"
=======
    def __repr__(self):
        # type: () -> str
        return "{class_name}({candidate!r})".format(
            class_name=self.__class__.__name__,
            candidate=self.candidate,
        )
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e

    @property
    def name(self):
        # type: () -> str
        # No need to canonicalise - the candidate did this
        return self.candidate.name

    def format_for_error(self):
        # type: () -> str
        return self.candidate.format_for_error()

    def get_candidate_lookup(self):
        # type: () -> CandidateLookup
        return self.candidate, None

    def is_satisfied_by(self, candidate):
        # type: (Candidate) -> bool
        return candidate == self.candidate


class SpecifierRequirement(Requirement):
    def __init__(self, ireq):
        # type: (InstallRequirement) -> None
        assert ireq.link is None, "This is a link, not a specifier"
        self._ireq = ireq
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
        self._equal_cache: Optional[str] = None
        self._hash: Optional[int] = None
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
        self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)
=======
        self._extras = frozenset(ireq.extras)
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208

<<<<<<< HEAD
    def __str__(self) -> str:
        return str(self._ireq.req)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({str(self._ireq.req)!r})"
=======
    def __str__(self):
        # type: () -> str
        return str(self._ireq.req)

    def __repr__(self):
        # type: () -> str
        return "{class_name}({requirement!r})".format(
            class_name=self.__class__.__name__,
            requirement=str(self._ireq.req),
        )
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e

    @property
    def name(self):
        # type: () -> str
        canonical_name = canonicalize_name(self._ireq.req.name)
        return format_name(canonical_name, self._extras)

    def format_for_error(self):
        # type: () -> str

        # Convert comma-separated specifiers into "A, B, ..., F and G"
        # This makes the specifier a bit more "human readable", without
        # risking a change in meaning. (Hopefully! Not all edge cases have
        # been checked)
        parts = [s.strip() for s in str(self).split(",")]
        if len(parts) == 0:
            return ""
        elif len(parts) == 1:
            return parts[0]

        return ", ".join(parts[:-1]) + " and " + parts[-1]

    def get_candidate_lookup(self):
        # type: () -> CandidateLookup
        return None, self._ireq

    def is_satisfied_by(self, candidate):
        # type: (Candidate) -> bool
        assert candidate.name == self.name, \
            "Internal issue: Candidate is not for this requirement " \
            " {} vs {}".format(candidate.name, self.name)
        # We can safely always allow prereleases here since PackageFinder
        # already implements the prerelease logic, and would have filtered out
        # prerelease candidates if the user does not expect them.
        spec = self._ireq.req.specifier
        return spec.contains(candidate.version, prereleases=True)


<<<<<<< HEAD
class SpecifierWithoutExtrasRequirement(SpecifierRequirement):
    """
    Requirement backed by an install requirement on a base package.
    Trims extras from its install requirement if there are any.
    """

    def __init__(self, ireq: InstallRequirement) -> None:
        assert ireq.link is None, "This is a link, not a specifier"
        self._ireq = install_req_drop_extras(ireq)
<<<<<<< HEAD
=======
        self._equal_cache: Optional[str] = None
        self._hash: Optional[int] = None
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
        self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)


=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
class RequiresPythonRequirement(Requirement):
    """A requirement representing Requires-Python metadata.
    """
    def __init__(self, specifier, match):
        # type: (SpecifierSet, Candidate) -> None
        self.specifier = specifier
<<<<<<< HEAD
<<<<<<< HEAD
=======
        self._specifier_string = str(specifier)  # for faster __eq__
        self._hash: Optional[int] = None
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
        self._candidate = match

    def __str__(self) -> str:
        return f"Python {self.specifier}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({str(self.specifier)!r})"
=======
        self._specifier_string = str(specifier)  # for faster __eq__
        self._hash: Optional[int] = None
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
        self._candidate = match

    def __repr__(self):
        # type: () -> str
        return "{class_name}({specifier!r})".format(
            class_name=self.__class__.__name__,
            specifier=str(self.specifier),
        )
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e

    @property
    def name(self):
        # type: () -> str
        return self._candidate.name

    def format_for_error(self):
        # type: () -> str
        return "Python " + str(self.specifier)

    def get_candidate_lookup(self):
        # type: () -> CandidateLookup
        if self.specifier.contains(self._candidate.version, prereleases=True):
            return self._candidate, None
        return None, None

    def is_satisfied_by(self, candidate):
        # type: (Candidate) -> bool
        assert candidate.name == self._candidate.name, "Not Python candidate"
        # We can safely always allow prereleases here since PackageFinder
        # already implements the prerelease logic, and would have filtered out
        # prerelease candidates if the user does not expect them.
        return self.specifier.contains(candidate.version, prereleases=True)
<<<<<<< HEAD


class UnsatisfiableRequirement(Requirement):
    """A requirement that cannot be satisfied."""

    def __init__(self, name: NormalizedName) -> None:
        self._name = name

    def __str__(self) -> str:
        return f"{self._name} (unavailable)"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({str(self._name)!r})"

    @property
    def project_name(self) -> NormalizedName:
        return self._name

    @property
    def name(self) -> str:
        return self._name

    def format_for_error(self) -> str:
        return str(self)

    def get_candidate_lookup(self) -> CandidateLookup:
        return None, None

    def is_satisfied_by(self, candidate: Candidate) -> bool:
        return False
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
