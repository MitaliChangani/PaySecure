from __future__ import annotations

import logging
import sys
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from typing import TYPE_CHECKING, Any, FrozenSet, Iterable, Optional, Tuple, Union, cast
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208

<<<<<<< HEAD
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
=======
from pip._vendor.contextlib2 import suppress
from pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet
from pip._vendor.packaging.utils import canonicalize_name
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
from pip._vendor.packaging.version import Version

<<<<<<< HEAD
from pip._internal.exceptions import (
    HashError,
    InstallationSubprocessError,
    MetadataInconsistent,
<<<<<<< HEAD
=======
    MetadataInvalid,
=======
from pip._internal.exceptions import HashError, MetadataInconsistent
from pip._internal.network.lazy_wheel import (
    HTTPRangeRequestUnsupported,
    dist_from_wheel_url,
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
from collections.abc import Iterable
from typing import TYPE_CHECKING, Any, Union, cast

from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version

=======
from collections.abc import Iterable
from typing import TYPE_CHECKING, Any, Union, cast

from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
from pip._internal.exceptions import (
    HashError,
    InstallationSubprocessError,
    InvalidInstalledPackage,
    MetadataInconsistent,
    MetadataInvalid,
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
)
from pip._internal.metadata import BaseDistribution
from pip._internal.models.link import Link, links_equivalent
from pip._internal.models.wheel import Wheel
from pip._internal.req.constructors import (
    install_req_from_editable,
    install_req_from_line,
)
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.direct_url_helpers import direct_url_from_link
from pip._internal.utils.misc import normalize_version_info

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from .base import Candidate, CandidateVersion, Requirement, format_name
=======
from .base import Candidate, format_name
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
from .base import Candidate, Requirement, format_name
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
from .base import Candidate, Requirement, format_name
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

if TYPE_CHECKING:
    from .factory import Factory

logger = logging.getLogger(__name__)

BaseCandidate = Union[
    "AlreadyInstalledCandidate",
    "EditableCandidate",
    "LinkCandidate",
]

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
# Avoid conflicting with the PyPI package "Python".
REQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, "<Python from Requires-Python>")


<<<<<<< HEAD
<<<<<<< HEAD
def as_base_candidate(candidate: Candidate) -> Optional[BaseCandidate]:
=======
def as_base_candidate(candidate: Candidate) -> BaseCandidate | None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
def as_base_candidate(candidate: Candidate) -> BaseCandidate | None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    """The runtime version of BaseCandidate."""
    base_candidate_classes = (
        AlreadyInstalledCandidate,
        EditableCandidate,
        LinkCandidate,
    )
    if isinstance(candidate, base_candidate_classes):
        return candidate
    return None


def make_install_req_from_link(
    link: Link, template: InstallRequirement
) -> InstallRequirement:
<<<<<<< HEAD
<<<<<<< HEAD
=======
def make_install_req_from_link(link, template):
    # type: (Link, InstallRequirement) -> InstallRequirement
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    assert not template.editable, "template is editable"
    if template.req:
        line = str(template.req)
    else:
        line = link.url
    ireq = install_req_from_line(
        line,
        user_supplied=template.user_supplied,
        comes_from=template.comes_from,
        use_pep517=template.use_pep517,
        isolated=template.isolated,
        constraint=template.constraint,
        global_options=template.global_options,
        hash_options=template.hash_options,
        config_settings=template.config_settings,
    )
    ireq.original_link = template.original_link
    ireq.link = link
    ireq.extras = template.extras
    return ireq


def make_install_req_from_editable(
    link: Link, template: InstallRequirement
) -> InstallRequirement:
    assert template.editable, "template not editable"
    ireq = install_req_from_editable(
        link.url,
        user_supplied=template.user_supplied,
        comes_from=template.comes_from,
        use_pep517=template.use_pep517,
        isolated=template.isolated,
        constraint=template.constraint,
        permit_editable_wheels=template.permit_editable_wheels,
        global_options=template.global_options,
        hash_options=template.hash_options,
        config_settings=template.config_settings,
    )
    ireq.extras = template.extras
    return ireq


def _make_install_req_from_dist(
    dist: BaseDistribution, template: InstallRequirement
) -> InstallRequirement:
    if template.req:
        line = str(template.req)
    elif template.link:
        line = f"{dist.canonical_name} @ {template.link.url}"
    else:
        line = f"{dist.canonical_name}=={dist.version}"
    ireq = install_req_from_line(
        line,
        user_supplied=template.user_supplied,
        comes_from=template.comes_from,
        use_pep517=template.use_pep517,
        isolated=template.isolated,
        constraint=template.constraint,
        global_options=template.global_options,
        hash_options=template.hash_options,
        config_settings=template.config_settings,
    )
    ireq.satisfied_by = dist
    return ireq


class _InstallRequirementBackedCandidate(Candidate):
    """A candidate backed by an ``InstallRequirement``.

    This represents a package request with the target not being already
    in the environment, and needs to be fetched and installed. The backing
    ``InstallRequirement`` is responsible for most of the leg work; this
    class exposes appropriate information to the resolver.

    :param link: The link passed to the ``InstallRequirement``. The backing
        ``InstallRequirement`` will use this link to fetch the distribution.
    :param source_link: The link this candidate "originates" from. This is
        different from ``link`` when the link is found in the wheel cache.
        ``link`` would point to the wheel cache, while this points to the
        found remote link (e.g. from pypi.org).
    """

    dist: BaseDistribution
    is_installed = False

    def __init__(
        self,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        link: Link,
        source_link: Link,
        ireq: InstallRequirement,
        factory: "Factory",
        name: Optional[NormalizedName] = None,
<<<<<<< HEAD
        version: Optional[CandidateVersion] = None,
=======
        version: Optional[Version] = None,
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    ) -> None:
=======
        link,          # type: Link
        source_link,   # type: Link
        ireq,          # type: InstallRequirement
        factory,       # type: Factory
        name=None,     # type: Optional[str]
        version=None,  # type: Optional[_BaseVersion]
    ):
        # type: (...) -> None
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        link: Link,
        source_link: Link,
        ireq: InstallRequirement,
        factory: Factory,
        name: NormalizedName | None = None,
        version: Version | None = None,
    ) -> None:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        self._link = link
        self._source_link = source_link
        self._factory = factory
        self._ireq = ireq
        self._name = name
        self._version = version
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        self.dist = self._prepare()
<<<<<<< HEAD
=======
        self._hash: Optional[int] = None
<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
=======
        self._dist = None  # type: Optional[Distribution]
        self._prepared = False
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
        self.dist = self._prepare()
        self._hash: int | None = None
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
        self.dist = self._prepare()
        self._hash: int | None = None
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

    def __str__(self) -> str:
        return f"{self.name} {self.version}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({str(self._link)!r})"
<<<<<<< HEAD

<<<<<<< HEAD
<<<<<<< HEAD
    def __hash__(self) -> int:
        return hash((self.__class__, self._link))

    def __eq__(self, other: Any) -> bool:
=======
    def __eq__(self, other):
        # type: (Any) -> bool
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
=======

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def __hash__(self) -> int:
        if self._hash is not None:
            return self._hash

        self._hash = hash((self.__class__, self._link))
        return self._hash

    def __eq__(self, other: Any) -> bool:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        if isinstance(other, self.__class__):
            return links_equivalent(self._link, other._link)
        return False

    @property
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def source_link(self) -> Optional[Link]:
=======
    def source_link(self):
        # type: () -> Optional[Link]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def source_link(self) -> Link | None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def source_link(self) -> Link | None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return self._source_link

    @property
    def project_name(self) -> NormalizedName:
        """The normalised name of the project the candidate refers to"""
        if self._name is None:
            self._name = self.dist.canonical_name
        return self._name

    @property
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def name(self) -> str:
        return self.project_name

    @property
    def version(self) -> CandidateVersion:
=======
    def version(self):
        # type: () -> _BaseVersion
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
        if self._version is None:
            self._version = self.dist.parsed_version
        return self._version

<<<<<<< HEAD
    def format_for_error(self) -> str:
        return "{} {} (from {})".format(
            self.name,
            self.version,
            self._link.file_path if self._link.is_file else self._link,
=======
    def format_for_error(self):
        # type: () -> str
        return "{} {} (from {})".format(
            self.name,
            self.version,
            self._link.file_path if self._link.is_file else self._link
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
        )

    def _prepare_abstract_distribution(self):
        # type: () -> AbstractDistribution
        raise NotImplementedError("Override in subclass")

    def _check_metadata_consistency(self):
        # type: () -> None
        """Check for consistency of project name and version of dist."""
<<<<<<< HEAD
        if self._name is not None and self._name != dist.canonical_name:
            raise MetadataInconsistent(
                self._ireq,
                "name",
                self._name,
                dist.canonical_name,
            )
        if self._version is not None and self._version != dist.version:
            raise MetadataInconsistent(
                self._ireq,
                "version",
                str(self._version),
                str(dist.version),
            )
=======
        # TODO: (Longer term) Rather than abort, reject this candidate
        #       and backtrack. This would need resolvelib support.
        dist = self._dist  # type: Distribution
        name = canonicalize_name(dist.project_name)
        if self._name is not None and self._name != name:
            raise MetadataInconsistent(self._ireq, "name", dist.project_name)
        version = dist.parsed_version
        if self._version is not None and self._version != version:
            raise MetadataInconsistent(self._ireq, "version", dist.version)
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e

    def _prepare(self):
        # type: () -> None
        if self._prepared:
            return
        try:
            abstract_dist = self._prepare_abstract_distribution()
        except HashError as e:
            e.req = self._ireq
            raise

        self._dist = abstract_dist.get_pkg_resources_distribution()
        assert self._dist is not None, "Distribution already installed"
        self._check_metadata_consistency()
        self._prepared = True

<<<<<<< HEAD
    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        requires = self.dist.iter_dependencies() if with_requires else ()
        for r in requires:
            yield from self._factory.make_requirements_from_spec(str(r), self._ireq)
        yield self._factory.make_requires_python_requirement(self.dist.requires_python)

    def get_install_requirement(self) -> Optional[InstallRequirement]:
=======
    def _fetch_metadata(self):
        # type: () -> None
        """Fetch metadata, using lazy wheel if possible."""
        preparer = self._factory.preparer
        use_lazy_wheel = self._factory.use_lazy_wheel
        remote_wheel = self._link.is_wheel and not self._link.is_file
        if use_lazy_wheel and remote_wheel and not preparer.require_hashes:
            assert self._name is not None
            logger.info('Collecting %s', self._ireq.req or self._ireq)
            # If HTTPRangeRequestUnsupported is raised, fallback silently.
            with indent_log(), suppress(HTTPRangeRequestUnsupported):
                logger.info(
                    'Obtaining dependency information from %s %s',
                    self._name, self._version,
                )
                url = self._link.url.split('#', 1)[0]
                session = preparer.downloader._session
                self._dist = dist_from_wheel_url(self._name, url, session)
                self._check_metadata_consistency()
        if self._dist is None:
            self._prepare()
=======
    def name(self) -> str:
        return self.project_name
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def name(self) -> str:
        return self.project_name
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

    @property
    def version(self) -> Version:
        if self._version is None:
            self._version = self.dist.version
        return self._version

    def format_for_error(self) -> str:
        return (
            f"{self.name} {self.version} "
            f"(from {self._link.file_path if self._link.is_file else self._link})"
        )

<<<<<<< HEAD
<<<<<<< HEAD
    def get_install_requirement(self):
        # type: () -> Optional[InstallRequirement]
        self._prepare()
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def _prepare_distribution(self) -> BaseDistribution:
        raise NotImplementedError("Override in subclass")

    def _check_metadata_consistency(self, dist: BaseDistribution) -> None:
        """Check for consistency of project name and version of dist."""
        if self._name is not None and self._name != dist.canonical_name:
            raise MetadataInconsistent(
                self._ireq,
                "name",
                self._name,
                dist.canonical_name,
            )
        if self._version is not None and self._version != dist.version:
            raise MetadataInconsistent(
                self._ireq,
                "version",
                str(self._version),
                str(dist.version),
            )
        # check dependencies are valid
        # TODO performance: this means we iterate the dependencies at least twice,
        # we may want to cache parsed Requires-Dist
        try:
            list(dist.iter_dependencies(list(dist.iter_provided_extras())))
        except InvalidRequirement as e:
            raise MetadataInvalid(self._ireq, str(e))

    def _prepare(self) -> BaseDistribution:
        try:
            dist = self._prepare_distribution()
        except HashError as e:
            # Provide HashError the underlying ireq that caused it. This
            # provides context for the resulting error message to show the
            # offending line to the user.
            e.req = self._ireq
            raise
        except InstallationSubprocessError as exc:
            # The output has been presented already, so don't duplicate it.
            exc.context = "See above for output."
            raise

        self._check_metadata_consistency(dist)
        return dist

    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
        # Emit the Requires-Python requirement first to fail fast on
        # unsupported candidates and avoid pointless downloads/preparation.
        yield self._factory.make_requires_python_requirement(self.dist.requires_python)
        requires = self.dist.iter_dependencies() if with_requires else ()
        for r in requires:
            yield from self._factory.make_requirements_from_spec(str(r), self._ireq)

    def get_install_requirement(self) -> InstallRequirement | None:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return self._ireq


class LinkCandidate(_InstallRequirementBackedCandidate):
    is_editable = False

    def __init__(
        self,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        link: Link,
        template: InstallRequirement,
        factory: "Factory",
        name: Optional[NormalizedName] = None,
<<<<<<< HEAD
        version: Optional[CandidateVersion] = None,
=======
        version: Optional[Version] = None,
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    ) -> None:
=======
        link,          # type: Link
        template,        # type: InstallRequirement
        factory,       # type: Factory
        name=None,     # type: Optional[str]
        version=None,  # type: Optional[_BaseVersion]
    ):
        # type: (...) -> None
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        link: Link,
        template: InstallRequirement,
        factory: Factory,
        name: NormalizedName | None = None,
        version: Version | None = None,
    ) -> None:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        source_link = link
        cache_entry = factory.get_wheel_cache_entry(source_link, name)
        if cache_entry is not None:
            logger.debug("Using cached wheel link: %s", cache_entry.link)
            link = cache_entry.link
        ireq = make_install_req_from_link(link, template)
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        assert ireq.link == link
        if ireq.link.is_wheel and not ireq.link.is_file:
            wheel = Wheel(ireq.link.filename)
            wheel_name = canonicalize_name(wheel.name)
            assert name == wheel_name, f"{name!r} != {wheel_name!r} for wheel"
            # Version may not be present for PEP 508 direct URLs
            if version is not None:
                wheel_version = Version(wheel.version)
<<<<<<< HEAD
<<<<<<< HEAD
                assert version == wheel_version, "{!r} != {!r} for wheel {}".format(
                    version, wheel_version, name
                )
=======
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
                assert (
                    version == wheel_version
                ), f"{version!r} != {wheel_version!r} for wheel {name}"
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
                assert (
                    version == wheel_version
                ), f"{version!r} != {wheel_version!r} for wheel {name}"
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

        if cache_entry is not None:
            assert ireq.link.is_wheel
            assert ireq.link.is_file
            if cache_entry.persistent and template.link is template.original_link:
                ireq.cached_wheel_source_link = source_link
            if cache_entry.origin is not None:
                ireq.download_info = cache_entry.origin
            else:
                # Legacy cache entry that does not have origin.json.
                # download_info may miss the archive_info.hashes field.
                ireq.download_info = direct_url_from_link(
                    source_link, link_is_in_wheel_cache=cache_entry.persistent
                )

        super().__init__(
            link=link,
            source_link=source_link,
            ireq=ireq,
            factory=factory,
            name=name,
            version=version,
        )

    def _prepare_distribution(self) -> BaseDistribution:
        preparer = self._factory.preparer
        return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)


class EditableCandidate(_InstallRequirementBackedCandidate):
    is_editable = True

    def __init__(
        self,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        link: Link,
        template: InstallRequirement,
        factory: "Factory",
        name: Optional[NormalizedName] = None,
<<<<<<< HEAD
        version: Optional[CandidateVersion] = None,
=======
        version: Optional[Version] = None,
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    ) -> None:
        super().__init__(
=======
        link,          # type: Link
        template,        # type: InstallRequirement
        factory,       # type: Factory
        name=None,     # type: Optional[str]
        version=None,  # type: Optional[_BaseVersion]
    ):
        # type: (...) -> None
        super(EditableCandidate, self).__init__(
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        link: Link,
        template: InstallRequirement,
        factory: Factory,
        name: NormalizedName | None = None,
        version: Version | None = None,
    ) -> None:
        super().__init__(
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
            link=link,
            source_link=link,
            ireq=make_install_req_from_editable(link, template),
            factory=factory,
            name=name,
            version=version,
        )

    def _prepare_distribution(self) -> BaseDistribution:
        return self._factory.preparer.prepare_editable_requirement(self._ireq)


class AlreadyInstalledCandidate(Candidate):
    is_installed = True
    source_link = None

    def __init__(
        self,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        dist: BaseDistribution,
        template: InstallRequirement,
        factory: "Factory",
    ) -> None:
=======
        dist,  # type: Distribution
        template,  # type: InstallRequirement
        factory,  # type: Factory
    ):
        # type: (...) -> None
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        dist: BaseDistribution,
        template: InstallRequirement,
        factory: Factory,
    ) -> None:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        self.dist = dist
        self._ireq = _make_install_req_from_dist(dist, template)
        self._factory = factory
        self._version = None

        # This is just logging some messages, so we can do it eagerly.
        # The returned dist would be exactly the same as self.dist because we
        # set satisfied_by in _make_install_req_from_dist.
        # TODO: Supply reason based on force_reinstall and upgrade_strategy.
        skip_reason = "already satisfied"
        factory.preparer.prepare_installed_requirement(self._ireq, skip_reason)

    def __str__(self) -> str:
        return str(self.dist)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.dist!r})"
<<<<<<< HEAD

<<<<<<< HEAD
<<<<<<< HEAD
    def __hash__(self) -> int:
        return hash((self.__class__, self.name, self.version))

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, self.__class__):
            return self.name == other.name and self.version == other.version
        return False
=======
    def __eq__(self, other):
        # type: (Any) -> bool
        if isinstance(other, self.__class__):
            return self.name == other.name and self.version == other.version
        return False

    # Needed for Python 2, which does not implement this by default
    def __ne__(self, other):
        # type: (Any) -> bool
        return not self.__eq__(other)
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, AlreadyInstalledCandidate):
            return NotImplemented
        return self.name == other.name and self.version == other.version

    def __hash__(self) -> int:
        return hash((self.name, self.version))
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, AlreadyInstalledCandidate):
            return NotImplemented
        return self.name == other.name and self.version == other.version

    def __hash__(self) -> int:
        return hash((self.name, self.version))
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

    @property
    def project_name(self) -> NormalizedName:
        return self.dist.canonical_name

    @property
    def name(self) -> str:
        return self.project_name

    @property
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def version(self) -> CandidateVersion:
        if self._version is None:
            self._version = self.dist.version
        return self._version
=======
    def is_editable(self):
        # type: () -> bool
        return dist_is_editable(self.dist)
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def version(self) -> Version:
        if self._version is None:
            self._version = self.dist.version
        return self._version
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

    @property
    def is_editable(self) -> bool:
        return self.dist.editable

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def format_for_error(self) -> str:
        return f"{self.name} {self.version} (Installed)"

    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        if not with_requires:
            return
        for r in self.dist.iter_dependencies():
            yield from self._factory.make_requirements_from_spec(str(r), self._ireq)

    def get_install_requirement(self) -> Optional[InstallRequirement]:
=======
    def iter_dependencies(self, with_requires):
        # type: (bool) -> Iterable[Optional[Requirement]]
=======
    def format_for_error(self) -> str:
        return f"{self.name} {self.version} (Installed)"

    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
        if not with_requires:
            return

<<<<<<< HEAD
    def get_install_requirement(self):
        # type: () -> Optional[InstallRequirement]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
    def format_for_error(self) -> str:
        return f"{self.name} {self.version} (Installed)"

    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
        if not with_requires:
            return

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        try:
            for r in self.dist.iter_dependencies():
                yield from self._factory.make_requirements_from_spec(str(r), self._ireq)
        except InvalidRequirement as exc:
            raise InvalidInstalledPackage(dist=self.dist, invalid_exc=exc) from None

    def get_install_requirement(self) -> InstallRequirement | None:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return None


class ExtrasCandidate(Candidate):
    """A candidate that has 'extras', indicating additional dependencies.

    Requirements can be for a project with dependencies, something like
    foo[extra].  The extras don't affect the project/version being installed
    directly, but indicate that we need additional dependencies. We model that
    by having an artificial ExtrasCandidate that wraps the "base" candidate.

    The ExtrasCandidate differs from the base in the following ways:

    1. It has a unique name, of the form foo[extra]. This causes the resolver
       to treat it as a separate node in the dependency graph.
    2. When we're getting the candidate's dependencies,
       a) We specify that we want the extra dependencies as well.
       b) We add a dependency on the base candidate.
          See below for why this is needed.
    3. We return None for the underlying InstallRequirement, as the base
       candidate will provide it, and we don't want to end up with duplicates.

    The dependency on the base candidate is needed so that the resolver can't
    decide that it should recommend foo[extra1] version 1.0 and foo[extra2]
    version 2.0. Having those candidates depend on foo=1.0 and foo=2.0
    respectively forces the resolver to recognise that this is a conflict.
    """

    def __init__(
        self,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        base: BaseCandidate,
        extras: FrozenSet[str],
        *,
        comes_from: Optional[InstallRequirement] = None,
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        base: BaseCandidate,
        extras: frozenset[str],
        *,
        comes_from: InstallRequirement | None = None,
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    ) -> None:
        """
        :param comes_from: the InstallRequirement that led to this candidate if it
            differs from the base's InstallRequirement. This will often be the
            case in the sense that this candidate's requirement has the extras
            while the base's does not. Unlike the InstallRequirement backed
            candidates, this requirement is used solely for reporting purposes,
            it does not do any leg work.
        """
<<<<<<< HEAD
<<<<<<< HEAD
=======
        base,  # type: BaseCandidate
        extras,  # type: FrozenSet[str]
    ):
        # type: (...) -> None
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
        self.base = base
<<<<<<< HEAD
        self.extras = frozenset(canonicalize_name(e) for e in extras)
        # If any extras are requested in their non-normalized forms, keep track
        # of their raw values. This is needed when we look up dependencies
        # since PEP 685 has not been implemented for marker-matching, and using
        # the non-normalized extra for lookup ensures the user can select a
        # non-normalized extra in a package with its non-normalized form.
        # TODO: Remove this attribute when packaging is upgraded to support the
        # marker comparison logic specified in PEP 685.
        self._unnormalized_extras = extras.difference(self.extras)
        self._comes_from = comes_from if comes_from is not None else self.base._ireq
=======
        self.extras = extras
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
        self.base = base
        self.extras = frozenset(canonicalize_name(e) for e in extras)
        self._comes_from = comes_from if comes_from is not None else self.base._ireq
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
        self.base = base
        self.extras = frozenset(canonicalize_name(e) for e in extras)
        self._comes_from = comes_from if comes_from is not None else self.base._ireq
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

    def __str__(self) -> str:
        name, rest = str(self.base).split(" ", 1)
        return "{}[{}] {}".format(name, ",".join(self.extras), rest)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(base={self.base!r}, extras={self.extras!r})"

    def __hash__(self) -> int:
        return hash((self.base, self.extras))

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, self.__class__):
            return self.base == other.base and self.extras == other.extras
        return False

    @property
    def project_name(self) -> NormalizedName:
        return self.base.project_name

    @property
    def name(self) -> str:
        """The normalised name of the project the candidate refers to"""
        return format_name(self.base.project_name, self.extras)

    @property
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def version(self) -> CandidateVersion:
=======
    def version(self):
        # type: () -> _BaseVersion
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
    def version(self) -> Version:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def version(self) -> Version:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return self.base.version

    def format_for_error(self) -> str:
        return "{} [{}]".format(
            self.base.format_for_error(), ", ".join(sorted(self.extras))
        )

    @property
    def is_installed(self) -> bool:
        return self.base.is_installed

    @property
    def is_editable(self) -> bool:
        return self.base.is_editable

    @property
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def source_link(self) -> Optional[Link]:
        return self.base.source_link

<<<<<<< HEAD
    def _warn_invalid_extras(
        self,
        requested: FrozenSet[str],
        valid: FrozenSet[str],
    ) -> None:
        """Emit warnings for invalid extras being requested.

        This emits a warning for each requested extra that is not in the
        candidate's ``Provides-Extra`` list.
        """
        invalid_extras_to_warn = frozenset(
            extra
            for extra in requested
            if extra not in valid
            # If an extra is requested in an unnormalized form, skip warning
            # about the normalized form being missing.
            and extra in self.extras
        )
        if not invalid_extras_to_warn:
            return
        for extra in sorted(invalid_extras_to_warn):
            logger.warning(
                "%s %s does not provide the extra '%s'",
                self.base.name,
                self.version,
                extra,
            )

    def _calculate_valid_requested_extras(self) -> FrozenSet[str]:
        """Get a list of valid extras requested by this candidate.

        The user (or upstream dependant) may have specified extras that the
        candidate doesn't support. Any unsupported extras are dropped, and each
        cause a warning to be logged here.
        """
        requested_extras = self.extras.union(self._unnormalized_extras)
        valid_extras = frozenset(
            extra
            for extra in requested_extras
            if self.base.dist.is_extra_provided(extra)
        )
        self._warn_invalid_extras(requested_extras, valid_extras)
        return valid_extras

=======
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
=======
    def source_link(self):
        # type: () -> Optional[Link]
        return self.base.source_link

    def iter_dependencies(self, with_requires):
        # type: (bool) -> Iterable[Optional[Requirement]]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def source_link(self) -> Link | None:
        return self.base.source_link

    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def source_link(self) -> Link | None:
        return self.base.source_link

    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        factory = self.base._factory

        # Add a dependency on the exact base
        # (See note 2b in the class docstring)
        yield factory.make_requirement_from_candidate(self.base)
        if not with_requires:
            return

<<<<<<< HEAD
        valid_extras = self._calculate_valid_requested_extras()
        for r in self.base.dist.iter_dependencies(valid_extras):
            yield from factory.make_requirements_from_spec(
                str(r),
                self._comes_from,
                valid_extras,
=======
        # The user may have specified extras that the candidate doesn't
        # support. We ignore any unsupported extras here.
        valid_extras = self.extras.intersection(self.base.dist.iter_provided_extras())
        invalid_extras = self.extras.difference(self.base.dist.iter_provided_extras())
        for extra in sorted(invalid_extras):
            logger.warning(
                "%s %s does not provide the extra '%s'",
                self.base.name,
                self.version,
                extra,
            )

<<<<<<< HEAD
<<<<<<< HEAD
        for r in self.base.dist.requires(valid_extras):
            requirement = factory.make_requirement_from_spec(
                str(r), self.base._ireq, valid_extras,
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        for r in self.base.dist.iter_dependencies(valid_extras):
            yield from factory.make_requirements_from_spec(
                str(r),
                self._comes_from,
                valid_extras,
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
            )

<<<<<<< HEAD
<<<<<<< HEAD
    def get_install_requirement(self) -> Optional[InstallRequirement]:
=======
    def get_install_requirement(self):
        # type: () -> Optional[InstallRequirement]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def get_install_requirement(self) -> InstallRequirement | None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
            )

    def get_install_requirement(self) -> InstallRequirement | None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        # We don't return anything here, because we always
        # depend on the base candidate, and we'll get the
        # install requirement from that.
        return None


class RequiresPythonCandidate(Candidate):
    is_installed = False
    source_link = None

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def __init__(self, py_version_info: Optional[Tuple[int, ...]]) -> None:
=======
    def __init__(self, py_version_info):
        # type: (Optional[Tuple[int, ...]]) -> None
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def __init__(self, py_version_info: tuple[int, ...] | None) -> None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def __init__(self, py_version_info: tuple[int, ...] | None) -> None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        if py_version_info is not None:
            version_info = normalize_version_info(py_version_info)
        else:
            version_info = sys.version_info[:3]
        self._version = Version(".".join(str(c) for c in version_info))

    # We don't need to implement __eq__() and __ne__() since there is always
    # only one RequiresPythonCandidate in a resolution, i.e. the host Python.
    # The built-in object.__eq__() and object.__ne__() do exactly what we want.

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def __str__(self) -> str:
        return f"Python {self._version}"
=======
    @property
    def name(self):
        # type: () -> str
        # Avoid conflicting with the PyPI package "Python".
        return "<Python from Requires-Python>"
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208

    @property
<<<<<<< HEAD
=======
    def __str__(self) -> str:
        return f"Python {self._version}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self._version!r})"

    @property
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def __str__(self) -> str:
        return f"Python {self._version}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self._version!r})"

    @property
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def project_name(self) -> NormalizedName:
        return REQUIRES_PYTHON_IDENTIFIER

    @property
    def name(self) -> str:
        return REQUIRES_PYTHON_IDENTIFIER

    @property
<<<<<<< HEAD
<<<<<<< HEAD
    def version(self) -> CandidateVersion:
=======
    def version(self):
        # type: () -> _BaseVersion
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
    def version(self) -> Version:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def version(self) -> Version:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return self._version

    def format_for_error(self) -> str:
        return f"Python {self.version}"

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        return ()

    def get_install_requirement(self) -> Optional[InstallRequirement]:
=======
    def iter_dependencies(self, with_requires):
        # type: (bool) -> Iterable[Optional[Requirement]]
        return ()

    def get_install_requirement(self):
        # type: () -> Optional[InstallRequirement]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
        return ()

    def get_install_requirement(self) -> InstallRequirement | None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
        return ()

    def get_install_requirement(self) -> InstallRequirement | None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return None
