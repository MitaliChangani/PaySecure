<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
import logging
from typing import List, Optional, Tuple
=======
# The following comment should be removed at some point in the future.
# mypy: disallow-untyped-defs=False

from __future__ import absolute_import

import logging
import os
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
from __future__ import annotations

import logging
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d

=======
from __future__ import annotations

import logging

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
from pip._internal.utils.misc import HiddenText, display_path
from pip._internal.utils.subprocess import make_command
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs.versioncontrol import (
    AuthInfo,
    RemoteNotFoundError,
    RevOptions,
    VersionControl,
    vcs,
)

logger = logging.getLogger(__name__)


class Bazaar(VersionControl):
    name = "bzr"
    dirname = ".bzr"
    repo_name = "branch"
    schemes = (
        "bzr+http",
        "bzr+https",
        "bzr+ssh",
        "bzr+sftp",
        "bzr+ftp",
        "bzr+lp",
        "bzr+file",
    )

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    @staticmethod
    def get_base_rev_args(rev: str) -> List[str]:
        return ["-r", rev]
=======
    def __init__(self, *args, **kwargs):
        super(Bazaar, self).__init__(*args, **kwargs)
        # This is only needed for python <2.7.5
        # Register lp but do not expose as a scheme to support bzr+lp.
        if getattr(urllib_parse, 'uses_fragment', None):
            urllib_parse.uses_fragment.extend(['lp'])
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208

=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    @staticmethod
    def get_base_rev_args(rev: str) -> list[str]:
        return ["-r", rev]

    def fetch_new(
        self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
    ) -> None:
        rev_display = rev_options.to_display()
        logger.info(
            "Checking out %s%s to %s",
            url,
            rev_display,
            display_path(dest),
        )
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        if verbosity <= 0:
            flag = "--quiet"
        elif verbosity == 1:
            flag = ""
        else:
            flag = f"-{'v'*verbosity}"
        cmd_args = make_command(
            "checkout", "--lightweight", flag, rev_options.to_args(), url, dest
=======
        cmd_args = (
            make_command('branch', '-q', rev_options.to_args(), url, dest)
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
        )
        self.run_command(cmd_args)

<<<<<<< HEAD
    def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        self.run_command(make_command("switch", url), cwd=dest)

    def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
=======
        if verbosity <= 0:
            flags = ["--quiet"]
        elif verbosity == 1:
            flags = []
        else:
            flags = [f"-{'v'*verbosity}"]
        cmd_args = make_command(
            "checkout", "--lightweight", *flags, rev_options.to_args(), url, dest
        )
        self.run_command(cmd_args)

    def switch(
        self,
        dest: str,
        url: HiddenText,
        rev_options: RevOptions,
        verbosity: int = 0,
    ) -> None:
        self.run_command(make_command("switch", url), cwd=dest)

    def update(
        self,
        dest: str,
        url: HiddenText,
        rev_options: RevOptions,
        verbosity: int = 0,
    ) -> None:
        flags = []

        if verbosity <= 0:
            flags.append("-q")

>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        output = self.run_command(
            make_command("info"), show_stdout=False, stdout_only=True, cwd=dest
        )
        if output.startswith("Standalone "):
            # Older versions of pip used to create standalone branches.
            # Convert the standalone branch to a checkout by calling "bzr bind".
<<<<<<< HEAD
            cmd_args = make_command("bind", "-q", url)
            self.run_command(cmd_args, cwd=dest)

        cmd_args = make_command("update", "-q", rev_options.to_args())
        self.run_command(cmd_args, cwd=dest)

    @classmethod
    def get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
        # hotfix the URL scheme after removing bzr+ from bzr+ssh:// re-add it
        url, rev, user_pass = super().get_url_rev_and_auth(url)
        if url.startswith("ssh://"):
            url = "bzr+" + url
=======
    def switch(self, dest, url, rev_options):
        # type: (str, HiddenText, RevOptions) -> None
        self.run_command(make_command('switch', url), cwd=dest)
=======
        if verbosity <= 0:
            flags = ["--quiet"]
        elif verbosity == 1:
            flags = []
        else:
            flags = [f"-{'v'*verbosity}"]
        cmd_args = make_command(
            "checkout", "--lightweight", *flags, rev_options.to_args(), url, dest
        )
        self.run_command(cmd_args)

    def switch(
        self,
        dest: str,
        url: HiddenText,
        rev_options: RevOptions,
        verbosity: int = 0,
    ) -> None:
        self.run_command(make_command("switch", url), cwd=dest)
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d

    def update(
        self,
        dest: str,
        url: HiddenText,
        rev_options: RevOptions,
        verbosity: int = 0,
    ) -> None:
        flags = []

        if verbosity <= 0:
            flags.append("-q")

        output = self.run_command(
            make_command("info"), show_stdout=False, stdout_only=True, cwd=dest
        )
        if output.startswith("Standalone "):
            # Older versions of pip used to create standalone branches.
            # Convert the standalone branch to a checkout by calling "bzr bind".
            cmd_args = make_command("bind", *flags, url)
            self.run_command(cmd_args, cwd=dest)

        cmd_args = make_command("update", *flags, rev_options.to_args())
        self.run_command(cmd_args, cwd=dest)

    @classmethod
<<<<<<< HEAD
    def get_url_rev_and_auth(cls, url):
        # type: (str) -> Tuple[str, Optional[str], AuthInfo]
        # hotfix the URL scheme after removing bzr+ from bzr+ssh:// readd it
        url, rev, user_pass = super(Bazaar, cls).get_url_rev_and_auth(url)
        if url.startswith('ssh://'):
            url = 'bzr+' + url
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
            cmd_args = make_command("bind", *flags, url)
            self.run_command(cmd_args, cwd=dest)

        cmd_args = make_command("update", *flags, rev_options.to_args())
        self.run_command(cmd_args, cwd=dest)

    @classmethod
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    def get_url_rev_and_auth(cls, url: str) -> tuple[str, str | None, AuthInfo]:
        # hotfix the URL scheme after removing bzr+ from bzr+ssh:// re-add it
        url, rev, user_pass = super().get_url_rev_and_auth(url)
        if url.startswith("ssh://"):
            url = "bzr+" + url
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        return url, rev, user_pass

    @classmethod
    def get_remote_url(cls, location: str) -> str:
        urls = cls.run_command(
            ["info"], show_stdout=False, stdout_only=True, cwd=location
        )
        for line in urls.splitlines():
            line = line.strip()
            for x in ("checkout of branch: ", "parent branch: "):
                if line.startswith(x):
                    repo = line.split(x)[1]
                    if cls._is_local_repository(repo):
                        return path_to_url(repo)
                    return repo
        raise RemoteNotFoundError

    @classmethod
    def get_revision(cls, location: str) -> str:
        revision = cls.run_command(
            ["revno"],
            show_stdout=False,
            stdout_only=True,
            cwd=location,
        )
        return revision.splitlines()[-1]

    @classmethod
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
=======
    def is_commit_id_equal(cls, dest, name):
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def is_commit_id_equal(cls, dest: str, name: str | None) -> bool:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def is_commit_id_equal(cls, dest: str, name: str | None) -> bool:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        """Always assume the versions don't match"""
        return False


vcs.register(Bazaar)
