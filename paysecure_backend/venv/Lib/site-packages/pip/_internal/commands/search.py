<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
from __future__ import absolute_import
=======
from __future__ import annotations
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
from __future__ import annotations
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
import logging
import shutil
import sys
import textwrap
import xmlrpc.client
from collections import OrderedDict
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from optparse import Values
<<<<<<< HEAD
from typing import TYPE_CHECKING, Dict, List, Optional
=======
from typing import TYPE_CHECKING, Dict, List, Optional, TypedDict
<<<<<<< HEAD
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df
=======
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
=======
from optparse import Values
from typing import TypedDict
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
from optparse import Values
from typing import TypedDict
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b

from pip._vendor.packaging.version import parse as parse_version

from pip._internal.cli.base_command import Command
from pip._internal.cli.req_command import SessionCommandMixin
from pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS
from pip._internal.exceptions import CommandError
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
from pip._internal.metadata import get_default_environment
=======
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import BaseDistribution
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
from pip._internal.models.index import PyPI
from pip._internal.network.xmlrpc import PipXmlrpcTransport
from pip._internal.utils.logging import indent_log
<<<<<<< HEAD
<<<<<<< HEAD
from pip._internal.utils.misc import write_output

if TYPE_CHECKING:
<<<<<<< HEAD
    from typing import TypedDict
=======
>>>>>>> ec9d79f070b8f6780957c47a12c2e943725352df

    class TransformedHit(TypedDict):
        name: str
        summary: str
        versions: List[str]
=======
from pip._internal.utils.misc import get_distribution, write_output
from pip._internal.utils.typing import MYPY_CHECK_RUNNING
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import BaseDistribution
from pip._internal.models.index import PyPI
from pip._internal.network.xmlrpc import PipXmlrpcTransport
from pip._internal.utils.logging import indent_log
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
from pip._internal.utils.misc import write_output


class TransformedHit(TypedDict):
    name: str
    summary: str
    versions: list[str]
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b


logger = logging.getLogger(__name__)


class SearchCommand(Command, SessionCommandMixin):
    """Search for PyPI packages whose name or summary contains <query>."""

    usage = """
      %prog [options] <query>"""
    ignore_require_venv = True

    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-i",
            "--index",
            dest="index",
            metavar="URL",
            default=PyPI.pypi_url,
            help="Base URL of Python Package Index (default %default)",
        )

        self.parser.insert_option_group(0, self.cmd_opts)

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def run(self, options: Values, args: List[str]) -> int:
=======
    def run(self, options, args):
        # type: (Values, List[str]) -> int
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def run(self, options: Values, args: list[str]) -> int:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def run(self, options: Values, args: list[str]) -> int:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        if not args:
            raise CommandError("Missing required argument (search query).")
        query = args
        pypi_hits = self.search(query, options)
        hits = transform_hits(pypi_hits)

        terminal_width = None
        if sys.stdout.isatty():
            terminal_width = shutil.get_terminal_size()[0]

        print_results(hits, terminal_width=terminal_width)
        if pypi_hits:
            return SUCCESS
        return NO_MATCHES_FOUND

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    def search(self, query: List[str], options: Values) -> List[Dict[str, str]]:
=======
    def search(self, query, options):
        # type: (List[str], Values) -> List[Dict[str, str]]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    def search(self, query: list[str], options: Values) -> list[dict[str, str]]:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    def search(self, query: list[str], options: Values) -> list[dict[str, str]]:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        index_url = options.index

        session = self.get_default_session(options)

        transport = PipXmlrpcTransport(index_url, session)
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        pypi = xmlrpc.client.ServerProxy(index_url, transport)
        try:
            hits = pypi.search({"name": query, "summary": query}, "or")
        except xmlrpc.client.Fault as fault:
<<<<<<< HEAD
<<<<<<< HEAD
            message = "XMLRPC request failed [code: {code}]\n{string}".format(
                code=fault.faultCode,
                string=fault.faultString,
            )
            raise CommandError(message)
        assert isinstance(hits, list)
=======
        pypi = xmlrpc_client.ServerProxy(index_url, transport)
        hits = pypi.search({'name': query, 'summary': query}, 'or')
>>>>>>> eee7fef9826be073fc05b85970f3b8ccb52f4c9e
        return hits


<<<<<<< HEAD
def transform_hits(hits: List[Dict[str, str]]) -> List["TransformedHit"]:
=======
def transform_hits(hits):
    # type: (List[Dict[str, str]]) -> List[TransformedHit]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
            message = (
                f"XMLRPC request failed [code: {fault.faultCode}]\n{fault.faultString}"
            )
            raise CommandError(message)
        assert isinstance(hits, list)
        return hits


def transform_hits(hits: list[dict[str, str]]) -> list[TransformedHit]:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
            message = (
                f"XMLRPC request failed [code: {fault.faultCode}]\n{fault.faultString}"
            )
            raise CommandError(message)
        assert isinstance(hits, list)
        return hits


def transform_hits(hits: list[dict[str, str]]) -> list[TransformedHit]:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    """
    The list from pypi is really a list of versions. We want a list of
    packages with the list of versions stored inline. This converts the
    list from pypi into one we can use.
    """
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    packages: Dict[str, "TransformedHit"] = OrderedDict()
=======
    packages = OrderedDict()  # type: OrderedDict[str, TransformedHit]
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
    packages: dict[str, TransformedHit] = OrderedDict()
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
    packages: dict[str, TransformedHit] = OrderedDict()
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    for hit in hits:
        name = hit["name"]
        summary = hit["summary"]
        version = hit["version"]

        if name not in packages.keys():
            packages[name] = {
                "name": name,
                "summary": summary,
                "versions": [version],
            }
        else:
            packages[name]["versions"].append(version)

            # if this is the highest version, replace summary and score
            if version == highest_version(packages[name]["versions"]):
                packages[name]["summary"] = summary

    return list(packages.values())


<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
def print_dist_installation_info(name: str, latest: str) -> None:
    env = get_default_environment()
    dist = env.get_distribution(name)
=======
def print_dist_installation_info(latest: str, dist: BaseDistribution | None) -> None:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
def print_dist_installation_info(latest: str, dist: BaseDistribution | None) -> None:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    if dist is not None:
        with indent_log():
            if dist.version == latest:
                write_output("INSTALLED: %s (latest)", dist.version)
            else:
                write_output("INSTALLED: %s", dist.version)
                if parse_version(latest).pre:
                    write_output(
                        "LATEST:    %s (pre-release; install"
                        " with `pip install --pre`)",
                        latest,
                    )
                else:
                    write_output("LATEST:    %s", latest)


<<<<<<< HEAD
<<<<<<< HEAD
def print_results(
    hits: List["TransformedHit"],
    name_column_width: Optional[int] = None,
    terminal_width: Optional[int] = None,
) -> None:
=======
def print_results(hits, name_column_width=None, terminal_width=None):
    # type: (List[TransformedHit], Optional[int], Optional[int]) -> None
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
def get_installed_distribution(name: str) -> BaseDistribution | None:
    env = get_default_environment()
    return env.get_distribution(name)


def print_results(
    hits: list[TransformedHit],
    name_column_width: int | None = None,
    terminal_width: int | None = None,
) -> None:
<<<<<<< HEAD
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    if not hits:
        return
    if name_column_width is None:
        name_column_width = (
            max(
                [
                    len(hit["name"]) + len(highest_version(hit.get("versions", ["-"])))
                    for hit in hits
                ]
            )
            + 4
        )

    for hit in hits:
        name = hit["name"]
        summary = hit["summary"] or ""
        latest = highest_version(hit.get("versions", ["-"]))
        if terminal_width is not None:
            target_width = terminal_width - name_column_width - 5
            if target_width > 10:
                # wrap and indent summary to fit terminal
                summary_lines = textwrap.wrap(summary, target_width)
                summary = ("\n" + " " * (name_column_width + 3)).join(summary_lines)

        name_latest = f"{name} ({latest})"
        line = f"{name_latest:{name_column_width}} - {summary}"
        try:
            write_output(line)
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
            print_dist_installation_info(name, latest)
=======
            if name in installed_packages:
                dist = get_distribution(name)
                assert dist is not None
                with indent_log():
                    if dist.version == latest:
                        write_output('INSTALLED: %s (latest)', dist.version)
                    else:
                        write_output('INSTALLED: %s', dist.version)
                        if parse_version(latest).pre:
                            write_output('LATEST:    %s (pre-release; install'
                                         ' with "pip install --pre")', latest)
                        else:
                            write_output('LATEST:    %s', latest)
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
            dist = get_installed_distribution(name)
            print_dist_installation_info(latest, dist)
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
            dist = get_installed_distribution(name)
            print_dist_installation_info(latest, dist)
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
        except UnicodeEncodeError:
            pass


<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
def highest_version(versions: List[str]) -> str:
=======
def highest_version(versions):
    # type: (List[str]) -> str
>>>>>>> 667482d8b430caa0727488b1d1900471cb8d5208
=======
def highest_version(versions: list[str]) -> str:
>>>>>>> c67f90bd6d99f24b568e213ed27f14d7420ce66d
=======
def highest_version(versions: list[str]) -> str:
>>>>>>> c386aa5fe352f969882abba769ec53b58b48337b
    return max(versions, key=parse_version)
